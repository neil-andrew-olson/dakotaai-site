<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota AI - Statistical Distribution Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

        :root {
            --primary: #4a5fd5;
            --secondary: #6b46c1;
            --accent: #d97706;
            --success: #059669;
            --warning: #d97706;
            --danger: #dc2626;
            --info: #0891b2;
            --dark: #1f2937;
            --light: #ffffff;
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            --glass: rgba(255, 255, 255, 0.35);
            --glass-border: rgba(255, 255, 255, 0.45);
            --glass-subtle: rgba(248, 250, 252, 0.8);
            --glass-subtle-border: rgba(241, 245, 249, 0.6);
            --shadow-soft: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 3px -1px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-hard: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --glow-primary: 0 0 15px rgba(74, 95, 213, 0.2);
            --glow-secondary: 0 0 15px rgba(107, 70, 193, 0.2);
            --glow-accent: 0 0 15px rgba(217, 119, 6, 0.2);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-secondary: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
            --gradient-accent: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            --gradient-success: linear-gradient(135deg, #34d399 0%, #10b981 100%);
            --animation-fast: 0.2s ease-out;
            --animation-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --animation-bounce: 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--light);
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg,
                rgba(249, 250, 251, 0.95) 0%,
                rgba(243, 244, 246, 0.9) 25%,
                rgba(229, 231, 235, 0.85) 50%,
                rgba(209, 213, 219, 0.8) 75%,
                rgba(156, 163, 175, 0.05) 100%);
            pointer-events: none;
            z-index: 1;
        }

        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(ellipse,
                rgba(74, 95, 213, 0.08) 0%,
                rgba(107, 70, 193, 0.05) 30%,
                rgba(217, 119, 6, 0.03) 60%,
                transparent 80%);
            animation: float 30s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: slideInUp 1s var(--animation-smooth);
        }

        .header h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            background: var(--gradient-accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            letter-spacing: -0.05em;
            text-shadow: var(--glow-accent);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(245, 158, 11, 0.5)); }
            to { filter: drop-shadow(0 0 15px rgba(245, 158, 11, 0.8)); }
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin: 20px 0 0 0;
            font-weight: 300;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .nav-tabs {
            display: flex;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 1.2s var(--animation-smooth);
        }

        .nav-tabs button {
            flex: 1;
            padding: 16px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            position: relative;
            transition: all var(--animation-fast);
            backdrop-filter: blur(10px);
        }

        .nav-tabs button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-primary);
            opacity: 0;
            transition: opacity var(--animation-fast);
            z-index: -1;
        }

        .nav-tabs button:hover {
            color: var(--light);
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-tabs button:hover::before {
            opacity: 0.3;
        }

        .nav-tabs button.active {
            color: var(--light);
            font-weight: 700;
            background: var(--glass);
        }

        .nav-tabs button.active::before {
            opacity: 1;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab-content {
            position: relative;
            perspective: 1000px;
        }

        .tab-panel {
            display: none;
            opacity: 0;
            transform: rotateY(90deg);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-origin: left center;
        }

        .tab-panel.active {
            display: block;
            opacity: 1;
            transform: rotateY(0deg);
        }

        .distribution-selector {
            margin-bottom: 40px;
            animation: slideInUp 1.4s var(--animation-smooth);
        }

        .distribution-selector h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--light);
        }

        .distribution-selector select {
            width: 100%;
            max-width: 400px;
            padding: 16px 20px;
            font-size: 1.1rem;
            font-weight: 500;
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            color: var(--light);
            cursor: pointer;
            transition: all var(--animation-fast);
            box-shadow: var(--shadow-soft);
        }

        .distribution-selector select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: var(--glow-primary), var(--shadow-medium);
            transform: scale(1.02);
        }

        .distribution-selector select:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-primary), var(--shadow-medium);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .data-input-section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 1.6s var(--animation-smooth);
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .data-input-section h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .data-input-controls {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 30px;
            align-items: start;
        }

        .input-method-selector {
            position: sticky;
            top: 20px;
        }

        .input-method-selector select {
            width: 100%;
            padding: 14px 18px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            background: var(--glass);
            backdrop-filter: blur(15px);
            color: var(--light);
            font-weight: 500;
            transition: all var(--animation-fast);
        }

        .params-panel {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 1.6s var(--animation-smooth);
        }

        .params-panel h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-secondary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .param-control {
            margin-bottom: 25px;
        }

        .param-control label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
        }

        .param-control input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            font-weight: 500;
            transition: all var(--animation-fast);
        }

        .param-control input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: var(--glow-primary);
            transform: scale(1.02);
        }

        .param-control input:hover {
            transform: scale(1.01);
        }

        .charts-panel {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .chart-container {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow-medium);
            transition: all var(--animation-smooth);
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            animation: rotate 10s linear infinite;
            pointer-events: none;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: var(--glow-primary), var(--shadow-hard);
        }

        .chart-container h4 {
            margin: 0 0 20px 0;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--light);
            text-align: center;
        }

        canvas {
            width: 100% !important;
            height: 350px !important;
            border-radius: 10px;
        }

        .stats-panel {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 2s var(--animation-smooth);
        }

        .stats-panel h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-success);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: var(--secondary);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            box-shadow: var(--shadow-soft);
            transition: all var(--animation-fast);
            position: relative;
            overflow: hidden;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: var(--gradient-accent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::after {
            left: 0;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--glow-secondary), var(--shadow-hard);
        }

        .stat-card .value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--light);
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-card .label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-panel {
            background: var(--glass);
            backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 35px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 2.2s var(--animation-smooth);
            line-height: 1.7;
        }

        .explanation-panel h3 {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .formula {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid var(--primary);
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.95);
            box-shadow: var(--shadow-soft);
        }

        .applications {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(56, 249, 215, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 4px solid var(--success);
            box-shadow: var(--shadow-soft);
        }

        .applications ul {
            margin: 0;
            padding-left: 25px;
        }

        .applications li {
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%);
            color: var(--danger);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .upload-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upload-controls input[type="file"] {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: var(--light);
        }

        .upload-controls select {
            padding: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--light);
        }

        .upload-controls button {
            padding: 12px 24px;
            background: var(--gradient-primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--animation-fast);
            box-shadow: var(--shadow-soft);
        }

        .upload-controls button:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-primary);
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .charts-panel {
                grid-template-columns: 1fr;
            }

            .data-input-controls {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .nav-tabs button {
                padding: 12px 16px;
                font-size: 0.9rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≤ Dakota AI Statistical Distribution Explorer</h1>
            <p>Interactive visualization of 22 probability distributions with real-time analysis and educational insights</p>
        </div>

        <div class="nav-tabs">
            <button class="active" onclick="showTab('parameters')">üìä Parameters & Data</button>
            <button onclick="showTab('visualizations')">üìà Visualizations</button>
            <button onclick="showTab('explanations')">üìö Theory</button>
        </div>

        <div class="tab-content">
            <div id="parameters" class="tab-panel active">
                <div class="distribution-selector">
                    <h3>üéØ Select Distribution</h3>
                    <select id="distributionSelect" onchange="loadDistribution()">
                        <optgroup label="Continuous Distributions" style="color: rgba(0,0,0,0.7);">
                            <option value="normal">üìä Normal Distribution</option>
                            <option value="beta">üéØ Beta Distribution</option>
                            <option value="gamma">üî• Gamma Distribution</option>
                            <option value="weibull">‚ö° Weibull Distribution</option>
                            <option value="pareto">üíé Pareto Distribution</option>
                            <option value="logistic">üìà Logistic Distribution</option>
                            <option value="laplace">‚¨© Laplace Distribution</option>
                            <option value="chisquared">Œß¬≤ Chi-Squared Distribution</option>
                            <option value="studentt">üìö Student-t Distribution</option>
                            <option value="fdist">üìä F-Distribution (Snedecor F)</option>
                            <option value="bivariate">üîó Bivariate Normal Distribution</option>
                            <option value="lognormal">üìâ Log-Normal Distribution</option>
                        </optgroup>
                        <optgroup label="Discrete Distributions" style="color: rgba(0,0,0,0.7);">
                            <option value="binomial">üé≤ Binomial Distribution</option>
                            <option value="poisson">üéØ Poisson Distribution</option>
                            <option value="geometric">üìê Geometric Distribution</option>
                            <option value="hypergeometric">üîÑ Hypergeometric Distribution</option>
                            <option value="multivariate">üîó Multivariate Hypergeometric</option>
                            <option value="negativebinomial">üìä Negative Binomial Distribution</option>
                            <option value="multinomial">üé≠ Multinomial Distribution</option>
                            <option value="uniform">üìè Discrete Uniform Distribution</option>
                        </optgroup>
                    </select>
                </div>

                <div class="data-input-section">
                    <h3>üìä Data Input & Analysis</h3>
                    <div class="data-input-controls">
                        <div class="input-method-selector">
                            <label for="dataMethodSelect">Data Source:</label>
                            <select id="dataMethodSelect" onchange="changeDataMethod()">
                                <option value="upload">üìÅ Upload CSV/Excel</option>
                                <option value="random">üé≤ Generate Random</option>
                                <option value="manual">‚úèÔ∏è Manual Entry</option>
                            </select>
                        </div>

                        <div id="uploadControls" style="display: block;" class="upload-controls">
                            <div class="param-control">
                                <label>Upload Data File:</label>
                                <input type="file" id="fileInput" accept=".csv,.xlsx,.xls,.txt"
                                       onchange="handleFileUpload(event)">
                            </div>
                            <div class="param-control">
                                <label for="columnSelect">Column:</label>
                                <select id="columnSelect">
                                    <option value="">Select a column...</option>
                                </select>
                            </div>
                            <button onclick="processUploadedData()">Process Data</button>
                        </div>

                        <div id="randomControls" style="display: none;" class="upload-controls">
                            <div class="param-control">
                                <label for="sampleSize">Sample Size:</label>
                                <input type="number" id="sampleSize" value="100" min="10" max="10000" step="10">
                            </div>
                            <button onclick="generateRandomData()">üé≤ Generate</button>
                        </div>

                        <div id="manualControls" style="display: none;" class="upload-controls">
                            <div class="param-control">
                                <label>Data (comma-separated):</label>
                                <textarea id="manualDataInput" rows="3" placeholder="1.2, 3.4, 2.1, 5.6..."
                                          style="width: 100%; resize: vertical;"></textarea>
                            </div>
                            <button onclick="processManualData()">üìù Process</button>
                        </div>
                    </div>
                </div>

                <div class="content-grid">
                    <div class="params-panel">
                        <h3>‚öôÔ∏è Distribution Parameters</h3>
                        <div id="paramsContainer">
                            <div class="loading">üîÑ Loading distribution parameters...</div>
                        </div>
                    </div>

                    <div class="stats-panel">
                        <h3>üìà Data Analysis Results</h3>
                        <div class="stats-grid" id="dataAnalysisResults">
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Data Points</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Mean</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Std Dev</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Skewness</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS Statistic</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS P-Value</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="stats-panel">
                    <h3>üìä Distribution Fitting</h3>
                    <div id="fittingResults">
                        <p style="color: rgba(255,255,255,0.7); margin: 0; text-align: center;">
                            üìÅ Upload data to see fitted parameters and goodness-of-fit results
                        </p>
                    </div>
                </div>
            </div>

            <div id="visualizations" class="tab-panel">
                <div class="charts-panel">
                    <div class="chart-container">
                        <h4>üìà Probability Density Function (PDF)</h4>
                        <canvas id="pdfChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h4>üìä Cumulative Distribution Function (CDF)</h4>
                        <canvas id="cdfChart"></canvas>
                    </div>
                </div>
                <div class="charts-panel">
                    <div class="chart-container" style="grid-column: span 2;">
                        <h4>üéØ Data Histogram & Distribution Fit</h4>
                        <canvas id="dataChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="explanations" class="tab-panel">
                <div class="explanation-panel">
                    <h3 id="distTitle">üìö Select a Distribution</h3>
                    <div id="explanationContent">
                        <div class="loading">üîÑ Loading explanation...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// Distribution definitions with parameters and explanations
        const distributions = {
            normal: {
                name: "Normal Distribution",
                params: [
                    { name: "Œº (mean)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "œÉ (standard deviation)", id: "sigma", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Normal distribution, discovered by Carl Friedrich Gauss, is the cornerstone of statistical inference and the Central Limit Theorem. It describes phenomena where many small, independent random effects combine additively.</p>

                    <div class="formula">
                    f(x; Œº, œÉ) = (1/(œÉ‚àö(2œÄ))) * exp(-((x-Œº)¬≤)/(2œÉ¬≤))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œº (mean)</strong>: Location parameter - determines the center/peak of the distribution</li>
                        <li><strong>œÉ (standard deviation)</strong>: Scale parameter - controls the spread/variance (œÉ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Measurement Science</strong>: Heights, weights, IQ scores, blood pressure</li>
                        <li><strong>Quality Control</strong>: Manufacturing tolerances, product specifications</li>
                        <li><strong>Finance</strong>: Stock returns (under log-normal assumptions), option pricing</li>
                        <li><strong>Natural Phenomena</strong>: Light intensity, particle velocities, astronomical measurements</li>
                        <li><strong>Psychometrics</strong>: Test scores, reaction times, cognitive abilities</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Symmetric with mean = median = mode = Œº</li>
                        <li>68-95-99.7 rule: 68% within 1œÉ, 95% within 1.96œÉ, 99.7% within 3œÉ</li>
                        <li>Inflection points at Œº ¬± œÉ</li>
                        <li>Maximum entropy distribution for given mean and variance</li>
                        <li>Stable under addition (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Historical Context:</strong> First derived by Abraham de Moivre in 1733 for binomial approximations. Gauss proved its universal importance in the theory of errors.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    // Using approximation for normal CDF
                    const mu = params.mu, sigma = params.sigma;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: mu,
                        variance: sigma * sigma,
                        skewness: 0,
                        kurtosis: 0,
                        median: mu,
                        mode: mu
                    };
                }
            },

            binomial: {
                name: "Binomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 100, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.5, min: 0, max: 1, step: 0.01 }
                ],
                explanation: `
                    <p>The Binomial distribution was developed by Jacob Bernoulli and is one of the earliest distributions in probability theory. It models scenarios where we conduct a fixed number of independent trials, each having exactly two possible outcomes (success/failure).</p>

                    <div class="formula">
                    P(X = k) = C(n,k) √ó p^k √ó (1-p)^(n-k)
                    </div>

                    <div class="formula" style="margin-top: 10px;">
                    C(n,k) = n! / (k! √ó (n-k)!)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n (number of trials)</strong>: Fixed sample size (must be a positive integer)</li>
                        <li><strong>p (success probability)</strong>: Probability of success on any single trial (0 ‚â§ p ‚â§ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Clinical Trials</strong>: Number of patients who respond to a treatment</li>
                        <li><strong>Quality Assurance</strong>: Proportion of defective products in a batch</li>
                        <li><strong>Elections</strong>: Number of votes for a candidate in exit polls</li>
                        <li><strong>A/B Testing</strong>: Conversion rates in website optimization</li>
                        <li><strong>Risk Assessment</strong>: Number of claims in an insurance portfolio</li>
                        <li><strong>Biology</strong>: Number of males in a litter of fixed size</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Mean = np, Variance = np(1-p)</li>
                        <li>Symmetric when p = 0.5, right-skewed when p < 0.5, left-skewed when p > 0.5</li>
                        <li>Maximum value is n (all successes), minimum is 0 (no successes)</li>
                        <li>Approaches Poisson distribution as n‚Üí‚àû and p‚Üí0 (with Œª = np fixed)</li>
                        <li>Approaches Normal distribution as n‚Üí‚àû (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Theoretical Foundations:</strong> Based on Bernoulli trials with independence assumption. Each trial must be identical and the outcome probabilities must remain constant across trials.</p>

                    <p><strong>Assumptions:</strong> Fixed number of trials, independence between trials, constant success probability, only two possible outcomes per trial.</p>
                `,
                pmf: (k, params) => {
                    const n = params.n, p = params.p;
                    if (k < 0 || k > n) return 0;
                    return math.combinations(n, k) * Math.pow(p, k) * Math.pow(1-p, n-k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const n = params.n, p = params.p;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p),
                        skewness: (1 - 2*p) / Math.sqrt(n * p * (1-p)),
                        kurtosis: (1 - 6*p*(1-p)) / (n * p * (1-p)),
                        median: Math.round(n * p),
                        mode: Math.round((n + 1) * p)
                    };
                }
            },

            poisson: {
                name: "Poisson Distribution",
                params: [
                    { name: "Œª (rate parameter)", id: "lambda", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Poisson distribution models the number of events occurring in a fixed interval of time or space.</p>

                    <div class="formula">
                    P(X = k) = e^(-Œª) * Œª^k / k!
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œª (lambda)</strong>: Average rate of events (Œª > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of customer arrivals per hour</li>
                        <li>Number of defects in a product</li>
                        <li>Number of phone calls received</li>
                        <li>Number of accidents at an intersection</li>
                        <li>Radioactive decay events</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete distribution. Mean = Variance = Œª. Right-skewed for small Œª, approaches normal as Œª increases.</p>
                `,
                pmf: (k, params) => {
                    const lambda = params.lambda;
                    if (k < 0) return 0;
                    return Math.exp(-lambda) * Math.pow(lambda, k) / math.factorial(k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const lambda = params.lambda;
                    return {
                        mean: lambda,
                        variance: lambda,
                        skewness: 1/Math.sqrt(lambda),
                        kurtosis: 1/lambda,
                        median: Math.round(lambda + 1/3 - 0.02/lambda),
                        mode: Math.floor(lambda)
                    };
                }
            },

            beta: {
                name: "Beta Distribution",
                params: [
                    { name: "Œ± (shape parameter)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "Œ≤ (shape parameter)", id: "beta", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Beta distribution models random variables whose values are constrained to a finite interval [0,1].</p>

                    <div class="formula">
                    f(x) = (x^(Œ±-1) * (1-x)^(Œ≤-1)) / B(Œ±,Œ≤)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œ± (alpha)</strong>: Shape parameter (Œ± > 0)</li>
                        <li><strong>Œ≤ (beta)</strong>: Shape parameter (Œ≤ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Proportions and rates between 0 and 1</li>
                        <li>Bayesian statistics (conjugate prior for Bernoulli)</li>
                        <li>Time allocation between activities</li>
                        <li>Quality control (percentage defective)</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shapes from uniform to U-shaped. Mean = Œ±/(Œ±+Œ≤), Variance = Œ±Œ≤/((Œ±+Œ≤)¬≤(Œ±+Œ≤+1)).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0 || x > 1) return 0;
                    const alpha = params.alpha, beta = params.beta;
                    return Math.pow(x, alpha-1) * Math.pow(1-x, beta-1) / math.beta(alpha, beta);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    if (x >= 1) return 1;
                    // Approximate using beta incomplete function
                    const alpha = params.alpha, beta = params.beta;
                    return math.betainc(x, alpha, beta);
                },
                stats: (params) => {
                    const alpha = params.alpha, beta = params.beta;
                    const total = alpha + beta;
                    return {
                        mean: alpha / total,
                        variance: (alpha * beta) / (total * total * (total + 1)),
                        skewness: (2 * (beta - alpha) * Math.sqrt(total + 1)) / ((total + 2) * Math.sqrt(alpha * beta)),
                        kurtosis: (6 * (alpha - beta) * (alpha - beta) * (total + 1) - alpha * beta * (total + 2)) / (alpha * beta * (total + 2) * (total + 3)),
                        median: (alpha - 1/3) / (total - 2/3), // approximation
                        mode: (alpha - 1) / (total - 2)
                    };
                }
            },

            gamma: {
                name: "Gamma Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "Œ∏ (scale)", id: "theta", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Gamma distribution generalizes the exponential distribution and is used for positive continuous variables.</p>

                    <div class="formula">
                    f(x) = (x^(k-1) * e^(-x/Œ∏)) / (Œ∏^k * Œì(k))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>Œ∏ (scale)</strong>: Scale parameter (Œ∏ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Waiting times between Poisson events</li>
                        <li>Life testing and reliability engineering</li>
                        <li>Size of insurance claims</li>
                        <li>Queueing theory</li>
                        <li>Bayesian statistics (conjugate prior)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal as k increases. Mean = kŒ∏, Variance = kŒ∏¬≤.</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, theta = params.theta;
                    return Math.pow(x, k-1) * Math.exp(-x/theta) / (Math.pow(theta, k) * math.gamma(k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, theta = params.theta;
                    return math.gammainc(k, x/theta);
                },
                stats: (params) => {
                    const k = params.k, theta = params.theta;
                    return {
                        mean: k * theta,
                        variance: k * theta * theta,
                        skewness: 2 / Math.sqrt(k),
                        kurtosis: 6 / k,
                        median: theta * (k - 1/3), // approximation
                        mode: theta * (k - 1)
                    };
                }
            },

            geometric: {
                name: "Geometric Distribution",
                params: [
                    { name: "p (success probability)", id: "p", default: 0.3, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Geometric distribution models the number of trials needed to get the first success in Bernoulli trials.</p>

                    <div class="formula">
                    P(X = k) = (1-p)^(k-1) * p
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>p</strong>: Probability of success in each trial (0 < p ‚â§ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of attempts needed to succeed</li>
                        <li>Reliability engineering (time to first failure)</li>
                        <li>Customer service (calls until first success)</li>
                        <li>Quality control (items inspected until first defect)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Memoryless property (like exponential distribution). Mean = 1/p, Variance = (1-p)/p¬≤.</p>
                `,
                pmf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return Math.pow(1-p, k-1) * p;
                },
                cdf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return 1 - Math.pow(1-p, k);
                },
                stats: (params) => {
                    const p = params.p;
                    return {
                        mean: 1/p,
                        variance: (1-p)/(p*p),
                        skewness: (2-p)/Math.sqrt(1-p),
                        kurtosis: (p*p - 6*p + 6)/(1-p),
                        median: Math.ceil(-Math.log(2)/Math.log(1-p)),
                        mode: 1
                    };
                }
            },

            hypergeometric: {
                name: "Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 2, max: 100, step: 1 },
                    { name: "K (success states)", id: "K", default: 7, min: 0, max: 20, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The Hypergeometric distribution models sampling without replacement from a finite population.</p>

                    <div class="formula">
                    P(X = k) = [C(K,k) √ó C(N-K,n-k)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size (N ‚â• 1)</li>
                        <li><strong>K</strong>: Number of successes in population (0 ‚â§ K ‚â§ N)</li>
                        <li><strong>n</strong>: Sample size without replacement (0 < n ‚â§ N)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (sampling from production lots)</li>
                        <li>Election auditing (sample verification)</li>
                        <li>Card games and lottery draws</li>
                        <li>Biological sampling (capture-recapture)</li>
                        <li>Mining and mineral exploration</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete, mean = nK/N, variance = nK/N(1-K/N)(N-n)/(N-1). Approaches binomial as N‚Üí‚àû.</p>
                `,
                pmf: (k, params) => {
                    const N = params.N, K = params.K, n = params.n;
                    if (k < Math.max(0, n - (N - K)) || k > Math.min(n, K)) return 0;
                    const comb1 = math.combinations(K, k);
                    const comb2 = math.combinations(N - K, n - k);
                    const comb3 = math.combinations(N, n);
                    return (comb1 * comb2) / comb3;
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const N = params.N, K = params.K, n = params.n;
                    const p = K / N;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p) * (N - n) / (N - 1),
                        skewness: ((N - 2*K) * Math.sqrt(N - 1) * Math.sqrt(N - n)) / (Math.sqrt(n * K * (N - K) * (N - n)) * Math.sqrt(N - 2)),
                        kurtosis: 'Complex calculation needed',
                        median: Math.round(n * K / N),
                        mode: Math.round((n + 1) * (K + 1) / (N + 2))
                    };
                }
            },

            multivariate: {
                name: "Multivariate Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 5, max: 100, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution used when there are multiple categories.</p>

                    <div class="formula">
                    P(X‚ÇÅ = k‚ÇÅ, X‚ÇÇ = k‚ÇÇ, ..., X‚Çò = k‚Çò) = [‚àè C(K·µ¢,k·µ¢)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size</li>
                        <li><strong>n</strong>: Sample size</li>
                        <li><strong>K‚±º</strong>: Size of each category in population</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election sampling with multiple parties</li>
                        <li>Contingency table analysis</li>
                        <li>Multiple classification sampling</li>
                        <li>Genetics and population studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multidimensional generalization of hypergeometric. Used in multivariate statistics and experimental design.</p>
                `,
                // Note: This is a simplification - true multivariate hypergeometric would need category sizes
                pmf: (k, params) => {
                    // This is a placeholder - multivariate hypergeometric is complex
                    return 0.1; // Placeholder value
                },
                cdf: (k, params) => {
                    // Approximation for demonstration
                    return 0.5;
                },
                stats: (params) => {
                    const N = params.N, n = params.n;
                    return {
                        mean: 'Multi-dimensional',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Multi-dimensional'
                    };
                }
            },

            negativebinomial: {
                name: "Negative Binomial Distribution",
                params: [
                    { name: "r (successes)", id: "r", default: 5, min: 1, max: 20, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.4, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Negative Binomial distribution models the number of trials needed to achieve a specified number of successes.</p>

                    <div class="formula">
                    P(X = k) = C(k-1,r-1) √ó p^r √ó (1-p)^(k-r)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>r</strong>: Number of successes required (r ‚â• 1)</li>
                        <li><strong>p</strong>: Probability of success on each trial (0 < p < 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (trials until r defects found)</li>
                        <li>Sales (attempts until r sales made)</li>
                        <li>Sports (games until r wins)</li>
                        <li>Reliability (failures until r successful tests)</li>
                        <li>Epidemiology (contacts until r infections)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Overdispersion compared to Poisson. Mean = r/p, Variance = r(1-p)/p¬≤. Special case of Poisson when r=1 (geometric).</p>
                `,
                pmf: (k, params) => {
                    const r = params.r, p = params.p;
                    if (k < r) return 0;
                    return math.combinations(k-1, r-1) * Math.pow(p, r) * Math.pow(1-p, k-r);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = params.r; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const r = params.r, p = params.p;
                    return {
                        mean: r / p,
                        variance: r * (1 - p) / (p * p),
                        skewness: (2 - p) / Math.sqrt(r * (1 - p)),
                        kurtosis: (p * p - 6 * p + 6) / (r * (1 - p)),
                        median: 'Approximation needed',
                        mode: Math.floor((r - 1) * (1 - p) / p) + r
                    };
                }
            },

            multinomial: {
                name: "Multinomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 50, step: 1 }
                ],
                explanation: `
                    <p>The Multinomial distribution is a generalization of the binomial distribution for experiments with more than two possible outcomes.</p>

                    <div class="formula">
                    P(X‚ÇÅ = k‚ÇÅ, X‚ÇÇ = k‚ÇÇ, ..., X‚Çò = k‚Çò) = [n! / (k‚ÇÅ!k‚ÇÇ!...k‚Çò!)] √ó p‚ÇÅ^k‚ÇÅ √ó p‚ÇÇ^k‚ÇÇ √ó ... √ó p‚Çò^k‚Çò
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n</strong>: Number of independent trials</li>
                        <li><strong>p‚±º</strong>: Probability of each outcome category (‚àëp‚±º = 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election results across multiple parties</li>
                        <li>Marketing response categories</li>
                        <li>Genetic inheritance patterns</li>
                        <li>Consumer preference studies</li>
                        <li>Disease classification studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multivariate generalization of binomial. Mean vector = n*p, covariance matrix = n*diag(p) - n*p*p^T.</p>
                `,
                // Note: This is highly simplified - multinomial distribution is complex for visualization
                pmf: (k, params) => {
                    // Placeholder - real multinomial is multivariate
                    return 0.1;
                },
                cdf: (k, params) => {
                    return 0.5;
                },
                stats: (params) => {
                    const n = params.n;
                    return {
                        mean: 'Vector-valued',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Complex'
                    };
                }
            },

            uniform: {
                name: "Continuous Uniform Distribution",
                params: [
                    { name: "a (min)", id: "a", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (max)", id: "b", default: 1, min: -10, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Continuous Uniform distribution has constant probability density over a finite interval.</p>

                    <div class="formula">
                    f(x) = 1/(b-a)  for a ‚â§ x ‚â§ b
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>a</strong>: Minimum value</li>
                        <li><strong>b</strong>: Maximum value (b > a)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Random number generation</li>
                        <li>Round-off errors</li>
                        <li>Physical measurements with limited precision</li>
                        <li>Simulation modeling</li>
                        <li>Bayesian prior (lack of information)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Rectangular shape. Mean = (a+b)/2, Variance = (b-a)¬≤/12. No mode (every value equally likely).</p>
                `,
                pdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x < a || x > b || a >= b) return 0;
                    return 1/(b-a);
                },
                cdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x <= a) return 0;
                    if (x >= b) return 1;
                    return (x - a)/(b - a);
                },
                stats: (params) => {
                    const a = params.a, b = params.b;
                    const range = b - a;
                    return {
                        mean: (a + b) / 2,
                        variance: range * range / 12,
                        skewness: 0,
                        kurtosis: -6/5,
                        median: (a + b) / 2,
                        mode: 'No unique mode (uniform)'
                    };
                }
            },

            studentt: {
                name: "Student-t Distribution",
                params: [
                    { name: "ŒΩ (degrees of freedom)", id: "df", default: 5, min: 0.1, max: 30, step: 0.1 }
                ],
                explanation: `
                    <p>The Student-t distribution arises from estimating the mean of a normally distributed population with unknown variance.</p>

                    <div class="formula">
                    f(x) = Œì((ŒΩ+1)/2) / (‚àö(ŒΩœÄ) * Œì(ŒΩ/2)) * (1 + x¬≤/ŒΩ)^(-(ŒΩ+1)/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>ŒΩ (degrees of freedom)</strong>: Shape parameter (ŒΩ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Statistical inference (t-tests)</li>
                        <li>Confidence intervals with small samples</li>
                        <li>Regression analysis</li>
                        <li>Bayesian statistics</li>
                        <li>Financial modeling (heavy tails)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric, bell-shaped but with heavier tails than normal. As ŒΩ‚Üí‚àû, approaches normal distribution. Mean = 0 for ŒΩ > 1, undefined otherwise.</p>
                `,
                pdf: (x, params) => {
                    const df = params.df;
                    const num = math.gamma((df + 1)/2);
                    const den = Math.sqrt(df * Math.PI) * math.gamma(df/2);
                    const factor = Math.pow(1 + x*x/df, -(df+1)/2);
                    return (num / den) * factor;
                },
                cdf: (x, params) => {
                    // Approximation for t-distribution CDF
                    const df = params.df;
                    if (df <= 0) return 0.5;

                    const z = x / Math.sqrt(1 + x*x/df);
                    const normal_cdf = 0.5 * (1 + math.erf(z/Math.sqrt(2)));
                    return normal_cdf;
                },
                stats: (params) => {
                    const df = params.df;
                    return {
                        mean: df > 1 ? 0 : 'Undefined',
                        variance: df > 2 ? df/(df-2) : 'Undefined',
                        skewness: df > 3 ? 0 : 'Undefined',
                        kurtosis: df > 4 ? 6/(df-4) : 'Undefined',
                        median: 0,
                        mode: 0
                    };
                }
            },

            weibull: {
                name: "Weibull Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 1.5, min: 0.1, max: 10, step: 0.1 },
                    { name: "Œª (scale)", id: "lambda", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Weibull distribution is widely used in reliability engineering and survival analysis.</p>

                    <div class="formula">
                    f(x) = (k/Œª) * (x/Œª)^(k-1) * exp(-(x/Œª)^k)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>Œª (scale)</strong>: Scale parameter (Œª > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Reliability engineering (failure times)</li>
                        <li>Survival analysis</li>
                        <li>Wind speed modeling</li>
                        <li>Material fatigue life</li>
                        <li>Product lifetime analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shape - exponential when k=1, right-skewed for k<1, approaches normal for large k. Mean = ŒªŒì(1+1/k), Variance = Œª¬≤[Œì(1+2/k) - Œì¬≤(1+1/k)].</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return (k/lambda) * Math.pow(x/lambda, k-1) * Math.exp(-Math.pow(x/lambda, k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return 1 - Math.exp(-Math.pow(x/lambda, k));
                },
                stats: (params) => {
                    const k = params.k, lambda = params.lambda;
                    return {
                        mean: lambda * math.gamma(1 + 1/k),
                        variance: lambda*lambda * (math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2)),
                        skewness: (math.gamma(1 + 3/k) - 3*math.gamma(1 + 1/k)*math.gamma(1 + 2/k) + 2*Math.pow(math.gamma(1 + 1/k), 3)) / Math.pow(math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2), 1.5),
                        kurtosis: 'Complex calculation needed',
                        median: lambda * Math.pow(Math.log(2), 1/k),
                        mode: lambda * Math.pow((k-1)/k, 1/k)
                    };
                }
            },

            pareto: {
                name: "Pareto Distribution",
                params: [
                    { name: "Œ± (shape)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "x‚ÇÄ (scale)", id: "x0", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Pareto distribution models phenomena where a small number of events account for a large proportion of outcomes.</p>

                    <div class="formula">
                    f(x) = Œ± x‚ÇÄ^Œ± / x^(Œ±+1)  for x ‚â• x‚ÇÄ
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œ± (shape)</strong>: Shape parameter (Œ± > 0)</li>
                        <li><strong>x‚ÇÄ (scale)</strong>: Minimum value (x‚ÇÄ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Income distribution (80/20 rule)</li>
                        <li>City population sizes</li>
                        <li>File size distribution</li>
                        <li>Insurance claims</li>
                        <li>Ecosystem species abundance</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Heavy tail, used in power-law phenomena. Mean = Œ±x‚ÇÄ/(Œ±-1) for Œ±>1. Variance undefined for Œ±‚â§2.</p>
                `,
                pdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x < x0) return 0;
                    return alpha * Math.pow(x0/alpha, alpha) / Math.pow(x, alpha + 1);
                },
                cdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x <= x0) return 0;
                    return 1 - Math.pow(x0/x, alpha);
                },
                stats: (params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    return {
                        mean: alpha > 1 ? (alpha * x0) / (alpha - 1) : 'Undefined',
                        variance: alpha > 2 ? (x0*x0 * alpha) / ((alpha - 1)*(alpha - 1) * (alpha - 2)) : 'Undefined',
                        skewness: alpha > 3 ? (2*(alpha + 1)/(alpha - 3)) * Math.sqrt((alpha - 2)/alpha) : 'Undefined',
                        kurtosis: 'Complex calculation needed',
                        median: x0 * Math.pow(2, 1/alpha),
                        mode: x0
                    };
                }
            },

            logistic: {
                name: "Logistic Distribution",
                params: [
                    { name: "Œº (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "s (scale)", id: "s", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Logistic distribution is used in growth models and as a smooth approximation to the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/s) * exp(-(x-Œº)/s) / (1 + exp(-(x-Œº)/s))¬≤
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œº (location)</strong>: Location parameter</li>
                        <li><strong>s (scale)</strong>: Scale parameter (s > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Growth models</li>
                        <li>Regression analysis</li>
                        <li>Neural networks (sigmoid activation)</li>
                        <li>Demographic modeling</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric distribution with heavier tails than normal. Mean = Œº, Variance = s¬≤œÄ¬≤/3. Used as link function in logistic regression.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    const exp_term = Math.exp(-(x - mu) / s);
                    return (1/s) * exp_term / Math.pow(1 + exp_term, 2);
                },
                cdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    return 1 / (1 + Math.exp(-(x - mu) / s));
                },
                stats: (params) => {
                    const mu = params.mu, s = params.s;
                    return {
                        mean: mu,
                        variance: s * s * Math.PI * Math.PI / 3,
                        skewness: 0,
                        kurtosis: 6/5,
                        median: mu,
                        mode: mu
                    };
                }
            },

            laplace: {
                name: "Laplace Distribution",
                params: [
                    { name: "Œº (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (scale)", id: "b", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Laplace distribution (also called double exponential) has heavier tails than the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/(2b)) * exp(-|x-Œº|/b)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œº (location)</strong>: Location parameter</li>
                        <li><strong>b (scale)</strong>: Scale parameter (b > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Modeling absolute deviations</li>
                        <li>Robust statistics</li>
                        <li>Signal processing</li>
                        <li>Finance (heavy tail modeling)</li>
                        <li>Atmospheric data analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric with sharper peak and heavier tails than normal. Mean = Œº, Variance = 2b¬≤. Maximum entropy distribution for given mean absolute deviation.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    return (1/(2*b)) * Math.exp(-Math.abs(x - mu)/b);
                },
                cdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    if (x < mu) {
                        return 0.5 * Math.exp((x - mu)/b);
                    } else {
                        return 1 - 0.5 * Math.exp((mu - x)/b);
                    }
                },
                stats: (params) => {
                    const mu = params.mu, b = params.b;
                    return {
                        mean: mu,
                        variance: 2 * b * b,
                        skewness: 0,
                        kurtosis: 3,
                        median: mu,
                        mode: mu
                    };
                }
            },

            chisquared: {
                name: "Chi-Squared Distribution",
                params: [
                    { name: "k (degrees of freedom)", id: "k", default: 5, min: 0.1, max: 20, step: 0.1 }
                ],
                explanation: `
                    <p>The Chi-Squared distribution arises from the sum of squares of independent standard normal random variables.</p>

                    <div class="formula">
                    f(x) = (1/(2^(k/2) * Œì(k/2))) * x^(k/2 - 1) * exp(-x/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (degrees of freedom)</strong>: Shape parameter (k > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Chi-squared tests for independence</li>
                        <li>Confidence interval construction</li>
                        <li>Goodness-of-fit tests</li>
                        <li>Variance estimation</li>
                        <li>Process capability analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal for large k. Mean = k, Variance = 2k. Support on (0,‚àû).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k;
                    return (1 / (Math.pow(2, k/2) * math.gamma(k/2))) * Math.pow(x, k/2 - 1) * Math.exp(-x/2);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k;
                    return math.gammainc(k/2, x/2);
                },
                stats: (params) => {
                    const k = params.k;
                    return {
                        mean: k,
                        variance: 2 * k,
                        skewness: Math.sqrt(8/k),
                        kurtosis: 12/k,
                        median: k * Math.pow(1 - 2/(9*k), 3), // approximation
                        mode: k - 2
                    };
                }
            },

            fdist: {
                name: "F-Distribution (Snedecor F)",
                params: [
                    { name: "d‚ÇÅ (numerator df)", id: "df1", default: 5, min: 0.1, max: 30, step: 0.1 },
                    { name: "d‚ÇÇ (denominator df)", id: "df2", default: 10, min: 0.1, max: 30, step: 0.1 }
                ],
                explanation: `
                    <p>The F-distribution (also known as Snedecor F-distribution or Fisher-Snedecor distribution) arises in the testing of whether two observed samples have the same variance.</p>

                    <div class="formula">
                    f(x) = (Œì((d‚ÇÅ+d‚ÇÇ)/2) / (Œì(d‚ÇÅ/2) * Œì(d‚ÇÇ/2))) * (d‚ÇÅ/d‚ÇÇ)^(d‚ÇÅ/2) * x^(d‚ÇÅ/2-1) * (1 + (d‚ÇÅ/d‚ÇÇ)x)^(-(d‚ÇÅ+d‚ÇÇ)/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>d‚ÇÅ (degrees of freedom numerator)</strong>: Shape parameter (d‚ÇÅ > 0)</li>
                        <li><strong>d‚ÇÇ (degrees of freedom denominator)</strong>: Shape parameter (d‚ÇÇ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>ANOVA (Analysis of Variance)</li>
                        <li>F-test for equality of variances</li>
                        <li>Regression analysis (F-test)</li>
                        <li>General linear models</li>
                        <li>Quality control (variance testing)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, continuous, support on (0,‚àû). Mean = d‚ÇÇ/(d‚ÇÇ-2) for d‚ÇÇ>2. Variance = 2d‚ÇÇ¬≤(d‚ÇÅ+d‚ÇÇ-2)/[d‚ÇÅ(d‚ÇÇ-2)¬≤(d‚ÇÇ-4)] for d‚ÇÇ>4.</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    const num = math.gamma((df1+df2)/2) * Math.pow(df1/df2, df1/2) * Math.pow(x, df1/2 - 1);
                    const den = math.gamma(df1/2) * math.gamma(df2/2) * Math.pow(1 + (df1/df2)*x, (df1+df2)/2);
                    return num / den;
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    // Approximation using beta function relationship
                    const z = (df1 * x) / (df1 * x + df2);
                    return math.betainc(z, df1/2, df2/2);
                },
                stats: (params) => {
                    const df1 = params.df1, df2 = params.df2;
                    return {
                        mean: df2 > 2 ? df2 / (df2 - 2) : 'Undefined',
                        variance: df2 > 4 ? (2 * df2 * df2 * (df1 + df2 - 2)) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4)) : 'Undefined',
                        skewness: 'Complex calculation needed',
                        kurtosis: 'Complex calculation needed',
                        median: 'Approximation needed',
                        mode: (df1 - 2)/df1 * df2/(df2 + 2) // approximation
                    };
                }
            },

            bivariate: {
                name: "Bivariate Normal Distribution",
                params: [
                    { name: "Œº‚ÇÅ (mean X)", id: "mu1", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "Œº‚ÇÇ (mean Y)", id: "mu2", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "œÉ‚ÇÅ (std X)", id: "sigma1", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "œÉ‚ÇÇ (std Y)", id: "sigma2", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "œÅ (correlation)", id: "rho", default: 0.5, min: -0.99, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The bivariate normal distribution is a generalization of the univariate normal distribution to two dimensions. It describes the joint behavior of two normally distributed random variables.</p>

                    <div class="formula">
                    f(x,y) = (1/(2œÄœÉ‚ÇÅœÉ‚ÇÇ‚àö(1-œÅ¬≤))) * exp[-1/(2(1-œÅ¬≤))] * [(x-Œº‚ÇÅ)¬≤/œÉ‚ÇÅ¬≤ - 2œÅ(x-Œº‚ÇÅ)(y-Œº‚ÇÇ)/(œÉ‚ÇÅœÉ‚ÇÇ) + (y-Œº‚ÇÇ)¬≤/œÉ‚ÇÇ¬≤]
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œº‚ÇÅ, Œº‚ÇÇ</strong>: Means for X and Y variables</li>
                        <li><strong>œÉ‚ÇÅ, œÉ‚ÇÇ</strong>: Standard deviations for X and Y variables</li>
                        <li><strong>œÅ</strong>: Correlation coefficient between X and Y (-1 ‚â§ œÅ ‚â§ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Multivariate analysis</li>
                        <li>Portfolio optimization (asset returns)</li>
                        <li>Biological measurements (height & weight)</li>
                        <li>Economic indicators</li>
                        <li>Quality control (multiple measurements)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Elliptical contours, marginal distributions are normal, conditional distributions are normal. Covariance = œÅœÉ‚ÇÅœÉ‚ÇÇ.</p>
                `,
                // Note: Bivariate normal is 2D - we'll provide marginal distributions for 1D plots
                pdf: (x, params) => {
                    // For visualization, we'll show the marginal distribution for X
                    const mu = params.mu1, sigma = params.sigma1;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    const mu = params.mu1, sigma = params.sigma1;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    return {
                        mean: `${params.mu1} (X), ${params.mu2} (Y)`,
                        variance: `${params.sigma1}¬≤ (X), ${params.sigma2}¬≤ (Y)`,
                        skewness: '0 (for both marginals)',
                        kurtosis: '0 (for both marginals)',
                        median: `${params.mu1} (X), ${params.mu2} (Y)`,
                        mode: `${params.mu1} (X), ${params.mu2} (Y)`
                    };
                }
            },

            lognormal: {
                name: "Log-Normal Distribution",
                params: [
                    { name: "Œº (log mean)", id: "mu", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "œÉ (log std dev)", id: "sigma", default: 1, min: 0.1, max: 3, step: 0.1 }
                ],
                explanation: `
                    <p>The log-normal distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed. It arises when the logarithm of a quantity is normally distributed.</p>

                    <div class="formula">
                    f(x) = (1/(xœÉ‚àö(2œÄ))) * exp[-(ln(x)-Œº)¬≤/(2œÉ¬≤)] for x > 0
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>Œº (log mean)</strong>: Mean of the logarithmic values</li>
                        <li><strong>œÉ (log std dev)</strong>: Standard deviation of the logarithmic values</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Stock prices (Black-Scholes model)</li>
                        <li>Particle sizes in materials</li>
                        <li>Income distributions</li>
                        <li>Survival times with multiplicative effects</li>
                        <li>Environmental concentrations</li>
                        <li>Reliability (failure times with multiple factors)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, support on (0,‚àû). Mean = exp(Œº + œÉ¬≤/2), Variance = exp(2Œº + œÉ¬≤)(exp(œÉ¬≤) - 1). Median = exp(Œº).</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const logx = Math.log(x);
                    return (1 / (x * sigma * Math.sqrt(2 * Math.PI))) *
                           Math.exp(-Math.pow(logx - mu, 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const z = (Math.log(x) - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: Math.exp(mu + sigma * sigma / 2),
                        variance: Math.exp(2*mu + sigma*sigma) * (Math.exp(sigma*sigma) - 1),
                        skewness: (Math.exp(sigma*sigma) + 2) * Math.sqrt(Math.exp(sigma*sigma) - 1),
                        kurtosis: Math.exp(4*sigma*sigma) + 2*Math.exp(3*sigma*sigma) + 3*Math.exp(2*sigma*sigma) - 6,
                        median: Math.exp(mu),
                        mode: Math.exp(mu - sigma*sigma)
                    };
                }
            }
        };

// Global variables for data analysis
let charts = {};
let currentDistribution = null;

// Distribution definitions with parameters and explanations
function showTab(tabName) {
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });

    document.querySelectorAll('.nav-tabs button').forEach(btn => {
        btn.classList.remove('active');
    });

    document.getElementById(tabName).classList.add('active');
    event.target.classList.add('active');
}

function loadDistribution() {
    const select = document.getElementById('distributionSelect');
    const distName = select.value;

    if (!distName) return;

    currentDistribution = distributions[distName];
    document.getElementById('distTitle').textContent = currentDistribution.name;
    renderParameters();
    updateStatistics();
    renderCharts();
    renderExplanation();
}

function renderParameters() {
    const container = document.getElementById('paramsContainer');
    container.innerHTML = '';

    currentDistribution.params.forEach(param => {
        const control = document.createElement('div');
        control.className = 'param-control';
        control.innerHTML = `
            <label for="${param.id}">${param.name}</label>
            <input type="number" id="${param.id}" value="${param.default}"
                   min="${param.min}" max="${param.max}" step="${param.step}"
                   oninput="updateStatistics(); renderCharts()">
        `;
        container.appendChild(control);
    });
}

function getCurrentParams() {
    const params = {};
    if (!currentDistribution) return params;

    currentDistribution.params.forEach(param => {
        const input = document.getElementById(param.id);
        params[param.id] = parseFloat(input ? input.value : param.default) || param.default;
    });
    return params;
}

function updateStatistics() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    try {
        const stats = currentDistribution.stats(params);
        const container = document.getElementById('statsContainer');
        container.innerHTML = `
            <div class="stat-card">
                <div class="value">${stats.mean.toFixed ? stats.mean.toFixed(3) : stats.mean}</div>
                <div class="label">Mean (Œº)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.variance.toFixed ? stats.variance.toFixed(3) : stats.variance}</div>
                <div class="label">Variance (œÉ¬≤)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.skewness.toFixed ? stats.skewness.toFixed(3) : stats.skewness}</div>
                <div class="label">Skewness</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.kurtosis.toFixed ? stats.kurtosis.toFixed(3) : stats.kurtosis}</div>
                <div class="label">Kurtosis</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.median.toFixed ? stats.median.toFixed(3) : stats.median}</div>
                <div class="label">Median</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.mode.toFixed ? stats.mode.toFixed(3) : stats.mode}</div>
                <div class="label">Mode</div>
            </div>
        `;
    } catch (e) {
        console.error('Error calculating statistics:', e);
        document.getElementById('statsContainer').innerHTML = '<div class="error">Error calculating statistics</div>';
    }
}

function renderCharts() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    let xMin, xMax, step;

    if (currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') || currentDistribution.name.includes('Geometric')) {
        xMin = 0;
        xMax = currentDistribution.name.includes('Binomial') ? params.n : (currentDistribution.name.includes('Geometric') ? Math.min(params.lambda * 3, 20) : params.lambda * 3);
        step = 1;
    } else if (currentDistribution.name.includes('Beta') || currentDistribution.name.includes('Uniform')) {
        xMin = currentDistribution.name.includes('Uniform') ? params.a : 0;
        xMax = currentDistribution.name.includes('Uniform') ? params.b : 1;
        step = currentDistribution.name.includes('Beta') ? 0.01 : 0.1;
    } else {
        xMin = -5;
        xMax = 5;
        step = 0.1;
    }

    const xValues = [];
    const pdfValues = [];
    const cdfValues = [];

    try {
        for (let x = xMin; x <= xMax; x += step) {
            xValues.push(x);
            const roundedX = Math.round(x);

            if (currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') || currentDistribution.name.includes('Geometric')) {
                pdfValues.push(roundedX === x ? currentDistribution.pmf(x, params) : 0);
                cdfValues.push(roundedX === x ? currentDistribution.cdf(x, params) : 0);
            } else {
                pdfValues.push(currentDistribution.pdf(x, params));
                cdfValues.push(currentDistribution.cdf(x, params));
            }
        }

        // PDF Chart
        const pdfCtx = document.getElementById('pdfChart').getContext('2d');
        if (charts.pdf) charts.pdf.destroy();
        charts.pdf = new Chart(pdfCtx, {
            type: 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: 'PDF',
                    data: pdfValues,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    fill: true,
                    pointRadius: (currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') || currentDistribution.name.includes('Geometric')) ? 3 : 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'x' } },
                    y: { title: { display: true, text: 'Density' } }
                },
                plugins: {
                    title: { display: true, text: 'Probability Density Function' }
                }
            }
        });

        // CDF Chart
        const cdfCtx = document.getElementById('cdfChart').getContext('2d');
        if (charts.cdf) charts.cdf.destroy();
        charts.cdf = new Chart(cdfCtx, {
            type: 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: 'CDF',
                    data: cdfValues,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    fill: true,
                    pointRadius: (currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') || currentDistribution.name.includes('Geometric')) ? 3 : 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'x' } },
                    y: { title: { display: true, text: 'Probability' }, min: 0, max: 1 }
                },
                plugins: {
                    title: { display: true, text: 'Cumulative Distribution Function' }
                }
            }
        });
    } catch (e) {
        console.error('Error rendering charts:', e);
        document.getElementById('pdfChart').getContext('2d').clearRect(0, 0, 400, 300);
        document.getElementById('cdfChart').getContext('2d').clearRect(0, 0, 400, 300);
    }
}

function renderExplanation() {
    const container = document.getElementById('explanationContent');
    container.innerHTML = currentDistribution.explanation;
}

// Global variables for data analysis
let currentData = [];

// Data input and analysis functions
function changeDataMethod() {
    const method = document.getElementById('dataMethodSelect').value;

    document.getElementById('uploadControls').style.display = method === 'upload' ? 'block' : 'none';
    document.getElementById('randomControls').style.display = method === 'random' ? 'block' : 'none';
    document.getElementById('manualControls').style.display = method === 'manual' ? 'block' : 'none';
}

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileType = file.name.split('.').pop().toLowerCase();

    if (fileType === 'csv') {
        parseCSVFile(file);
    } else if (fileType === 'xlsx' || fileType === 'xls') {
        parseExcelFile(file);
    } else {
        alert('Please upload a CSV or Excel file.');
    }
}

function parseCSVFile(file) {
    Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        complete: function(results) {
            if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file.');
                return;
            }

            const columns = Object.keys(results.data[0] || {});
            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            columns.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                columnSelect.appendChild(option);
            });

            window.parsedData = results.data.filter(row =>
                Object.values(row).some(val =>
                    typeof val === 'number' && !isNaN(val)
                )
            );

            alert(`File parsed successfully! Found ${columns.length} columns and ${window.parsedData.length} rows with numeric data.`);
        },
        error: function(error) {
            console.error('CSV parsing error:', error);
            alert('Error parsing CSV file: ' + error.message);
        }
    });
}

function parseExcelFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });

            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                defval: null
            });

            if (jsonData.length === 0) {
                alert('Excel file is empty.');
                return;
            }

            const headers = jsonData[0];
            const rows = jsonData.slice(1);

            const objectData = rows.map(row => {
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = row[i];
                });
                return obj;
            });

            window.parsedData = objectData;

            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                columnSelect.appendChild(option);
            });

            alert(`Excel file parsed successfully! Found ${headers.length} columns and ${rows.length} rows.`);
        } catch (error) {
            console.error('Excel parsing error:', error);
            alert('Error parsing Excel file: ' + error.message);
        }
    };

    reader.readAsArrayBuffer(file);
}

function processUploadedData() {
    const columnName = document.getElementById('columnSelect').value;
    if (!columnName || !window.parsedData) {
        alert('Please select a column and ensure data is loaded.');
        return;
    }

    const rawData = window.parsedData
        .map(row => row[columnName])
        .filter(val => typeof val === 'number' && !isNaN(val));

    if (rawData.length === 0) {
        alert('No valid numeric data found in the selected column.');
        return;
    }

    currentData = rawData;
    analyzeData(currentData);
}

function generateRandomData() {
    if (!currentDistribution) {
        alert('Please select a distribution first.');
        return;
    }

    const sampleSize = parseInt(document.getElementById('sampleSize').value) || 100;
    const params = getCurrentParams();

    const randomData = [];

    if (currentDistribution.name === 'Normal Distribution') {
        for (let i = 0; i < sampleSize; i++) {
            const u1 = Math.random();
            const u2 = Math.random();
            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            randomData.push(params.mu + z * Math.sqrt(params.sigma));
        }
    } else {
        // Fallback: basic random generation
        for (let i = 0; i < sampleSize; i++) {
            randomData.push(Math.random());
        }
    }

    currentData = randomData;
    analyzeData(currentData);
}

function processManualData() {
    const manualText = document.getElementById('manualDataInput').value.trim();
    if (!manualText) {
        alert('Please enter some data.');
        return;
    }

    try {
        const values = manualText.split(',')
            .map(s => s.trim())
            .map(s => parseFloat(s))
            .filter(n => !isNaN(n));

        if (values.length === 0) {
            alert('No valid numeric values found.');
            return;
        }

        currentData = values;
        analyzeData(currentData);
    } catch (error) {
        alert('Error parsing manual data: ' + error.message);
    }
}

function analyzeData(data) {
    if (data.length === 0) return;

    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
    const stdDev = Math.sqrt(variance);
    const skewness = calculateSkewness(data, mean, stdDev);
    const median = calculateMedian(data);

    displayDataAnalysisResults(data.length, mean, stdDev, skewness, median);
    renderDataChart(data);
}

function calculateSkewness(data, mean, stdDev) {
    const n = data.length;
    const skewness = data.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / n;
    return skewness;
}

function calculateMedian(data) {
    const sorted = [...data].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function displayDataAnalysisResults(count, mean, stdDev, skewness, median) {
    const kstest = performKSTest(currentData);

    document.getElementById('dataAnalysisResults').innerHTML = `
        <div class="stat-card">
            <div class="value">${count}</div>
            <div class="label">Data Points</div>
        </div>
        <div class="stat-card">
            <div class="value">${mean.toFixed(3)}</div>
            <div class="label">Mean</div>
        </div>
        <div class="stat-card">
            <div class="value">${stdDev.toFixed(3)}</div>
            <div class="label">Std Dev</div>
        </div>
        <div class="stat-card">
            <div class="value">${skewness.toFixed(3)}</div>
            <div class="label">Skewness</div>
        </div>
        <div class="stat-card">
            <div class="value">${kstest ? kstest.statistic.toFixed(3) : '--'}</div>
            <div class="label">KS Statistic</div>
        </div>
        <div class="stat-card">
            <div class="value">${kstest ? kstest.pValue.toFixed(3) : '--'}</div>
            <div class="label">KS P-Value</div>
        </div>
    `;

    displayFittingResults();
}

function performKSTest(data) {
    if (!currentDistribution || !data.length) return null;

    const sortedData = [...data].sort((a, b) => a - b);
    const params = getCurrentParams();

    let maxDifference = 0;

    sortedData.forEach((value, index) => {
        const empiricalCDF = (index + 0.5) / sortedData.length;
        let theoreticalCDF = 0.5; // fallback

        try {
            if (currentDistribution.name === 'Normal Distribution') {
                const z = (value - params.mu) / Math.sqrt(params.sigma);
                theoreticalCDF = 0.5 * (1 + math.erf(z / Math.sqrt(2)));
            } else if (currentDistribution.name === 'Uniform Distribution') {
                theoreticalCDF = (value - params.a) / (params.b - params.a);
                theoreticalCDF = Math.max(0, Math.min(1, theoreticalCDF));
            }
        } catch (e) {
            console.warn('CDF calculation error:', e);
        }

        const difference = Math.abs(empiricalCDF - theoreticalCDF);
        maxDifference = Math.max(maxDifference, difference);
    });

    const pValue = maxDifference < 0.1 ? 0.8 : maxDifference < 0.2 ? 0.5 : 0.05;

    return { statistic: maxDifference, pValue: pValue };
}

function displayFittingResults() {
    const container = document.getElementById('fittingResults');
    const params = getCurrentParams();

    let resultsHTML = '<h4>üìä Fitted Parameters:</h4><ul>';

    Object.entries(params).forEach(([param, value]) => {
        resultsHTML += `<li><strong>${param}:</strong> ${value.toFixed(4)}</li>`;
    });

    resultsHTML += '</ul>';

    container.innerHTML = resultsHTML;
}

function renderDataChart(data) {
    const ctx = document.getElementById('dataChart').getContext('2d');

    const minVal = Math.min(...data);
    const maxVal = Math.max(...data);
    const binCount = Math.min(30, Math.ceil(Math.sqrt(data.length)));

    const binWidth = (maxVal - minVal) / binCount;
    const bins = Array(binCount).fill(0);

    data.forEach(value => {
        const binIndex = Math.min(binCount - 1, Math.floor((value - minVal) / binWidth));
        bins[binIndex]++;
    });

    const binLabels = [];
    for (let i = 0; i < binCount; i++) {
        const binStart = minVal + i * binWidth;
        const binEnd = binStart + binWidth;
        binLabels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
    }

    const datasets = [{
        label: 'Histogram',
        data: bins,
        backgroundColor: 'rgba(16, 185, 129, 0.5)',
        borderColor: 'rgba(16, 185, 129, 1)',
        borderWidth: 1,
        type: 'bar'
    }];

    if (charts.data) charts.data.destroy();
    charts.data = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: binLabels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Frequency' }
                },
                x: {
                    title: { display: true, text: 'Value Range' }
                }
            },
            plugins: {
                title: { display: true, text: 'Data Histogram & Distribution Fit' }
            }
        }
    });
}

// Initialize first distribution
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('distributionSelect').value = 'normal';
    loadDistribution();
    changeDataMethod();
});
    </script>
</body>
</html>
