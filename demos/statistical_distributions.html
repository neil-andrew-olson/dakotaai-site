<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota AI - Statistical Distribution Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');

        :root {
            /* Light Theme (Default) */
            --primary: #2563eb;
            --secondary: #7c3aed;
            --accent: #d97706;
            --success: #059669;
            --warning: #d97706;
            --danger: #dc2626;
            --info: #0891b2;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --glass: rgba(255, 255, 255, 0.8);
            --glass-border: rgba(0, 0, 0, 0.1);
            --shadow: rgba(0, 0, 0, 0.1);
            --glow: rgba(37, 99, 235, 0.1);
        }

        [data-theme="dark"] {
            /* Dark Theme */
            --primary: #60a5fa;
            --secondary: #a78bfa;
            --accent: #fbbf24;
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #f87171;
            --info: #22d3ee;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border: #334155;
            --glass: rgba(30, 41, 59, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow: rgba(0, 0, 0, 0.3);
            --glow: rgba(96, 165, 250, 0.15);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--light);
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg,
                rgba(249, 250, 251, 0.95) 0%,
                rgba(243, 244, 246, 0.9) 25%,
                rgba(229, 231, 235, 0.85) 50%,
                rgba(209, 213, 219, 0.8) 75%,
                rgba(156, 163, 175, 0.05) 100%);
            pointer-events: none;
            z-index: 1;
        }

        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(ellipse,
                rgba(74, 95, 213, 0.08) 0%,
                rgba(107, 70, 193, 0.05) 30%,
                rgba(217, 119, 6, 0.03) 60%,
                transparent 80%);
            animation: float 30s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            padding: 20px;
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 8px;
            cursor: pointer;
            transition: all var(--animation-fast);
            box-shadow: var(--shadow-medium);
        }

        .theme-toggle:hover {
            transform: scale(1.05);
            box-shadow: var(--glow-primary), var(--shadow-hard);
        }

        .theme-toggle svg {
            width: 24px;
            height: 24px;
            fill: var(--text-primary);
            transition: all var(--animation-fast);
        }

        .theme-toggle:hover svg {
            transform: rotate(45deg);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: slideInUp 1s var(--animation-smooth);
        }

        .header h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            background: var(--gradient-accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            letter-spacing: -0.05em;
            text-shadow: var(--glow-accent);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(245, 158, 11, 0.5)); }
            to { filter: drop-shadow(0 0 15px rgba(245, 158, 11, 0.8)); }
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin: 20px 0 0 0;
            font-weight: 300;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .nav-tabs {
            display: flex;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 1.2s var(--animation-smooth);
        }

        .nav-tabs button {
            flex: 1;
            padding: 16px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            position: relative;
            transition: all var(--animation-fast);
            backdrop-filter: blur(10px);
        }

        .nav-tabs button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-primary);
            opacity: 0;
            transition: opacity var(--animation-fast);
            z-index: -1;
        }

        .nav-tabs button:hover {
            color: var(--light);
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-tabs button:hover::before {
            opacity: 0.3;
        }

        .nav-tabs button.active {
            color: var(--light);
            font-weight: 700;
            background: var(--glass);
        }

        .nav-tabs button.active::before {
            opacity: 1;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab-content {
            position: relative;
            perspective: 1000px;
        }

        .tab-panel {
            display: none;
            opacity: 0;
            transform: rotateY(90deg);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-origin: left center;
        }

        .tab-panel.active {
            display: block;
            opacity: 1;
            transform: rotateY(0deg);
        }

        .distribution-selector {
            margin-bottom: 40px;
            animation: slideInUp 1.4s var(--animation-smooth);
        }

        .distribution-selector h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--light);
        }

        .distribution-selector select {
            width: 100%;
            max-width: 400px;
            padding: 16px 20px;
            font-size: 1.1rem;
            font-weight: 500;
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            color: var(--light);
            cursor: pointer;
            transition: all var(--animation-fast);
            box-shadow: var(--shadow-soft);
        }

        .distribution-selector select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: var(--glow-primary), var(--shadow-medium);
            transform: scale(1.02);
        }

        .distribution-selector select:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-primary), var(--shadow-medium);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .data-input-section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 1.6s var(--animation-smooth);
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .data-input-section h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-accent);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .data-input-controls {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 30px;
            align-items: start;
        }

        .input-method-selector {
            position: sticky;
            top: 20px;
        }

        .input-method-selector select {
            width: 100%;
            padding: 14px 18px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            background: var(--glass);
            backdrop-filter: blur(15px);
            color: var(--light);
            font-weight: 500;
            transition: all var(--animation-fast);
        }

        .params-panel {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 1.6s var(--animation-smooth);
        }

        .params-panel h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-secondary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .param-control {
            margin-bottom: 25px;
        }

        .param-control label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
        }

        .param-control input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 1rem;
            font-weight: 500;
            transition: all var(--animation-fast);
        }

        .param-control input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: var(--glow-primary);
            transform: scale(1.02);
        }

        .param-control input:hover {
            transform: scale(1.01);
        }

        .charts-panel {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .chart-container {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow-medium);
            transition: all var(--animation-smooth);
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            animation: rotate 10s linear infinite;
            pointer-events: none;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: var(--glow-primary), var(--shadow-hard);
        }

        .chart-container h4 {
            margin: 0 0 20px 0;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--light);
            text-align: center;
        }

        canvas {
            width: 100% !important;
            height: 350px !important;
            border-radius: 10px;
        }

        .stats-panel {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 2s var(--animation-smooth);
        }

        .stats-panel h3 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-success);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: var(--secondary);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            box-shadow: var(--shadow-soft);
            transition: all var(--animation-fast);
            position: relative;
            overflow: hidden;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: var(--gradient-accent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::after {
            left: 0;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--glow-secondary), var(--shadow-hard);
        }

        .stat-card .value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--light);
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-card .label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .explanation-panel {
            background: var(--glass);
            backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 35px;
            box-shadow: var(--shadow-medium);
            animation: fadeInScale 2.2s var(--animation-smooth);
            line-height: 1.7;
        }

        .explanation-panel h3 {
            font-size: 1.6rem;
            font-weight: 700;
            margin-bottom: 25px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .formula {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid var(--primary);
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.95);
            box-shadow: var(--shadow-soft);
        }

        .applications {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(56, 249, 215, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 4px solid var(--success);
            box-shadow: var(--shadow-soft);
        }

        .applications ul {
            margin: 0;
            padding-left: 25px;
        }

        .applications li {
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%);
            color: var(--danger);
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .upload-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upload-controls input[type="file"] {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: var(--light);
        }

        .upload-controls select {
            padding: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--light);
        }

        .upload-controls button {
            padding: 12px 24px;
            background: var(--gradient-primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--animation-fast);
            box-shadow: var(--shadow-soft);
        }

        .upload-controls button:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-primary);
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .charts-panel {
                grid-template-columns: 1fr;
            }

            .data-input-controls {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .nav-tabs button {
                padding: 12px 16px;
                font-size: 0.9rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <button id="themeToggle" class="theme-toggle">
        <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/>
        </svg>
    </button>

    <div class="container">
        <div class="header">
            <h1>🎲 Dakota AI Statistical Distribution Explorer</h1>
            <p>Interactive visualization of 22 probability distributions with real-time analysis and educational insights</p>
        </div>

        <div class="nav-tabs">
            <button class="active" onclick="showTab('parameters')">📊 Parameters & Data</button>
            <button onclick="showTab('visualizations')">📈 Visualizations</button>
            <button onclick="showTab('explanations')">📚 Theory</button>
        </div>

        <div class="tab-content">
            <div id="parameters" class="tab-panel active">
                <div class="distribution-selector">
                    <h3>🎯 Select Distribution</h3>
                    <select id="distributionSelect" onchange="loadDistribution()">
                        <optgroup label="Continuous Distributions" style="color: rgba(0,0,0,0.7);">
                            <option value="normal">📊 Normal Distribution</option>
                            <option value="beta">🎯 Beta Distribution</option>
                            <option value="gamma">🔥 Gamma Distribution</option>
                            <option value="weibull">⚡ Weibull Distribution</option>
                            <option value="pareto">💎 Pareto Distribution</option>
                            <option value="logistic">📈 Logistic Distribution</option>
                            <option value="laplace">⬩ Laplace Distribution</option>
                            <option value="chisquared">Χ² Chi-Squared Distribution</option>
                            <option value="studentt">📚 Student-t Distribution</option>
                            <option value="fdist">📊 F-Distribution (Snedecor F)</option>
                            <option value="bivariate">🔗 Bivariate Normal Distribution</option>
                            <option value="lognormal">📉 Log-Normal Distribution</option>
                        </optgroup>
                        <optgroup label="Discrete Distributions" style="color: rgba(0,0,0,0.7);">
                            <option value="binomial">🎲 Binomial Distribution</option>
                            <option value="poisson">🎯 Poisson Distribution</option>
                            <option value="geometric">📐 Geometric Distribution</option>
                            <option value="hypergeometric">🔄 Hypergeometric Distribution</option>
                            <option value="multivariate">🔗 Multivariate Hypergeometric</option>
                            <option value="negativebinomial">📊 Negative Binomial Distribution</option>
                            <option value="multinomial">🎭 Multinomial Distribution</option>
                            <option value="uniform">📏 Discrete Uniform Distribution</option>
                        </optgroup>
                    </select>
                </div>

                <div class="data-input-section">
                    <h3>📊 Data Input & Analysis</h3>
                    <div class="data-input-controls">
                        <div class="input-method-selector">
                            <label for="dataMethodSelect">Data Source:</label>
                            <select id="dataMethodSelect" onchange="changeDataMethod()">
                                <option value="upload">📁 Upload CSV/Excel</option>
                                <option value="random">🎲 Generate Random</option>
                                <option value="manual">✏️ Manual Entry</option>
                            </select>
                        </div>

                        <div id="uploadControls" style="display: block;" class="upload-controls">
                            <div class="param-control">
                                <label>Upload Data File:</label>
                                <input type="file" id="fileInput" accept=".csv,.xlsx,.xls,.txt"
                                       onchange="handleFileUpload(event)">
                            </div>
                            <div class="param-control">
                                <label for="columnSelect">Column:</label>
                                <select id="columnSelect">
                                    <option value="">Select a column...</option>
                                </select>
                            </div>
                            <button onclick="processUploadedData()">Process Data</button>
                        </div>

                        <div id="randomControls" style="display: none;" class="upload-controls">
                            <div class="param-control">
                                <label for="sampleSize">Sample Size:</label>
                                <input type="number" id="sampleSize" value="100" min="10" max="10000" step="10">
                            </div>
                            <button onclick="generateRandomData()">🎲 Generate</button>
                        </div>

                        <div id="manualControls" style="display: none;" class="upload-controls">
                            <div class="param-control">
                                <label>Data (comma-separated):</label>
                                <textarea id="manualDataInput" rows="3" placeholder="1.2, 3.4, 2.1, 5.6..."
                                          style="width: 100%; resize: vertical;"></textarea>
                            </div>
                            <button onclick="processManualData()">📝 Process</button>
                        </div>
                    </div>
                </div>

                <div class="content-grid">
                    <div class="params-panel">
                        <h3>⚙️ Distribution Parameters</h3>
                        <div id="paramsContainer">
                            <div class="loading">🔄 Loading distribution parameters...</div>
                        </div>
                    </div>

                    <div class="stats-panel">
                        <h3>📈 Data Analysis Results</h3>
                        <div class="stats-grid" id="dataAnalysisResults">
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Data Points</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Mean</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Std Dev</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Skewness</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS Statistic</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS P-Value</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="stats-panel">
                    <h3>📊 Distribution Fitting</h3>
                    <div id="fittingResults">
                        <p style="color: rgba(255,255,255,0.7); margin: 0; text-align: center;">
                            📁 Upload data to see fitted parameters and goodness-of-fit results
                        </p>
                    </div>
                </div>
            </div>

            <div id="visualizations" class="tab-panel">
                <div class="charts-panel">
                    <div class="chart-container">
                        <h4>📈 Probability Density Function (PDF)</h4>
                        <canvas id="pdfChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h4>📊 Cumulative Distribution Function (CDF)</h4>
                        <canvas id="cdfChart"></canvas>
                    </div>
                </div>
                <div class="charts-panel">
                    <div class="chart-container" style="grid-column: span 2;">
                        <h4>🎯 Data Histogram & Distribution Fit</h4>
                        <canvas id="dataChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="explanations" class="tab-panel">
                <div class="explanation-panel">
                    <h3>📚 Statistical Distribution Theory</h3>

                    <h4>🎯 What are Probability Distributions?</h4>
                    <p>A probability distribution describes how the values of a random variable are distributed. It specifies the probabilities of different outcomes or ranges of outcomes.</p>

                    <h4>📊 Continuous vs Discrete Distributions</h4>
                    <ul>
                        <li><strong>Continuous Distributions:</strong> Random variables can take any value within a continuous range (e.g., Normal, Beta, Gamma)</li>
                        <li><strong>Discrete Distributions:</strong> Random variables take only distinct, separate values (e.g., Binomial, Poisson, Geometric)</li>
                    </ul>

                    <h4>📈 Distribution Families & Applications</h4>

                    <div class="formula" style="margin-top: 20px;">
                    <strong>CONTINUOUS DISTRIBUTIONS</strong>
                    </div>

                    <h5>🔔 Normal Distribution (Gaussian)</h5>
                    <div class="formula">f(x) = (1/(σ√(2π))) * exp(-((x-μ)²)/(2σ²))</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Measurement errors in physical experiments</li>
                        <li>Height, weight, IQ scores in populations</li>
                        <li>Stock returns under normal assumptions</li>
                        <li>Quality control tolerances</li>
                    </ul>
                    </div>

                    <h5>🎯 Beta Distribution</h5>
                    <div class="formula">f(x) = (x^(α-1) * (1-x)^(β-1)) / B(α,β)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Bayesian statistics (conjugate prior for Bernoulli)</li>
                        <li>Proportions and rates between 0-1</li>
                        <li>Project completion百分比</li>
                        <li>Acceptance probabilities in quality control</li>
                    </ul>
                    </div>

                    <h5>🔥 Gamma Distribution</h5>
                    <div class="formula">f(x) = (x^(k-1) * e^(-x/θ)) / (θ^k * Γ(k))</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Waiting times between Poisson events</li>
                        <li>Reliability engineering (component lifetimes)</li>
                        <li>Insurance claims amounts</li>
                        <li>Rainfall amounts, tornado intensities</li>
                    </ul>
                    </div>

                    <h5>⚡ Weibull Distribution</h5>
                    <div class="formula">f(x) = (k/λ) * (x/λ)^(k-1) * exp(-(x/λ)^k)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Failure analysis and reliability engineering</li>
                        <li>Wind speed modeling</li>
                        <li>Material fatigue life analysis</li>
                        <li>Product lifetime testing</li>
                    </ul>
                    </div>

                    <h5>💎 Pareto Distribution (Power Law)</h5>
                    <div class="formula">f(x) = α x₀^α / x^(α+1)  for x ≥ x₀</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Income inequality analysis (80/20 rule)</li>
                        <li>City population sizes</li>
                        <li>File size distributions in networks</li>
                        <li>Insurance claims with high deductibles</li>
                    </ul>
                    </div>

                    <h5>📉 Log-Normal Distribution</h5>
                    <div class="formula">f(x) = (1/(xσ√(2π))) * exp[-(ln(x)-μ)²/(2σ²)]</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Stock prices in Black-Scholes model</li>
                        <li>Particle sizes in materials science</li>
                        <li>Concentrations in environmental studies</li>
                        <li>Survival times with multiplicative effects</li>
                    </ul>
                    </div>

                    <h5>⚖️ Student-t Distribution</h5>
                    <div class="formula">f(x) = Γ((ν+1)/2) / (√(νπ) * Γ(ν/2)) * (1 + x²/ν)^(-(ν+1)/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Statistical inference with small samples (t-tests)</li>
                        <li>Confidence intervals when population variance unknown</li>
                        <li>Regression analysis residuals</li>
                        <li>Robust statistical methods</li>
                    </ul>
                    </div>

                    <h5>⏹️ Uniform Distribution (Continuous)</h5>
                    <div class="formula">f(x) = 1/(b-a)  for a ≤ x ≤ b</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Random number generation</li>
                        <li>Round-off errors in measurements</li>
                        <li>Physical measurements with limited precision</li>
                        <li>Bayesian prior for lack of information</li>
                    </ul>
                    </div>

                    <h5>📈 Logistic Distribution</h5>
                    <div class="formula">f(x) = (1/s) * exp(-(x-μ)/s) / (1 + exp(-(x-μ)/s))²</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Growth models in biology and economics</li>
                        <li>Neural network activation functions</li>
                        <li>Probit/logit regression models</li>
                        <li>Demographic population modeling</li>
                    </ul>
                    </div>

                    <h5>⬩ Laplace Distribution (Double Exponential)</h5>
                    <div class="formula">f(x) = (1/(2b)) * exp(-|x-μ|/b)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Modeling absolute deviations/errors</li>
                        <li>Robust statistics alternatives to normal</li>
                        <li>Signal processing with heavy tails</li>
                        <li>Financial modeling of extreme events</li>
                    </ul>
                    </div>

                    <h5>✅ Chi-Squared Distribution</h5>
                    <div class="formula">f(x) = (1/(2^(k/2) * Γ(k/2))) * x^(k/2 - 1) * exp(-x/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Chi-squared tests for independence</li>
                        <li>Goodness-of-fit tests</li>
                        <li>Variance estimation and testing</li>
                        <li>Quality control and process capability</li>
                    </ul>
                    </div>

                    <h5>📊 F-Distribution (Snedecor F)</h5>
                    <div class="formula">f(x) = Γ((d₁+d₂)/2) / Γ(d₁/2)Γ(d₂/2) * (d₁/d₂)^(d₁/2) * x^(d₁/2-1) * (1 + (d₁/d₂)x)^(-(d₁+d₂)/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>ANOVA (Analysis of Variance)</li>
                        <li>F-tests for equal variances</li>
                        <li>Regression analysis significance tests</li>
                        <li>Generalized linear models</li>
                    </ul>
                    </div>

                    <h5>🔗 Bivariate Normal Distribution</h5>
                    <div class="formula">f(x,y) = (1/(2πσ₁σ₂√(1-ρ²))) * exp[-1/(2(1-ρ²))] * [(x-μ₁)²/σ₁² - 2ρ(x-μ₁)(y-μ₂)/(σ₁σ₂) + (y-μ₂)²/σ₂²]</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Multivariate analysis of correlated variables</li>
                        <li>Asset returns in portfolio optimization</li>
                        <li>Biological measurements (height-weight correlations)</li>
                        <li>Economic indicators analysis</li>
                    </ul>
                    </div>

                    <div class="formula" style="margin-top: 30px;">
                    <strong>DISCRETE DISTRIBUTIONS</strong>
                    </div>

                    <h5>🎲 Binomial Distribution</h5>
                    <div class="formula">P(X = k) = C(n,k) × p^k × (1-p)^(n-k)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Success/failure experiments with fixed trials</li>
                        <li>Quality control (defective items in sample)</li>
                        <li>Election outcomes in voting polls</li>
                        <li>Clinical trials response counts</li>
                    </ul>
                    </div>

                    <h5>🎯 Poisson Distribution</h5>
                    <div class="formula">P(X = k) = e^(-λ) * λ^k / k!</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Events occurring in fixed time/space intervals</li>
                        <li>Customer arrivals at service centers</li>
                        <li>Radioactive decay events counting</li>
                        <li>Traffic accidents at intersections</li>
                    </ul>
                    </div>

                    <h5>📐 Geometric Distribution</h5>
                    <div class="formula">P(X = k) = (1-p)^(k-1) * p</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Waiting time until first success</li>
                        <li>Reliability (trials until first failure)</li>
                        <li>Quality control (items until first defect)</li>
                        <li>Sales calls until first sale</li>
                    </ul>
                    </div>

                    <h5>🔄 Hypergeometric Distribution</h5>
                    <div class="formula">P(X = k) = [C(K,k) × C(N-K,n-k)] / C(N,n)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Sampling without replacement from finite populations</li>
                        <li>Quality control lot sampling</li>
                        <li>Election auditing procedures</li>
                        <li>Card game probability calculations</li>
                    </ul>
                    </div>

                    <h5>📊 Negative Binomial Distribution</h5>
                    <div class="formula">P(X = k) = C(k-1,r-1) × p^r × (1-p)^(k-r)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Number of trials needed for r successes</li>
                        <li>Quality control (trials until r defects)</li>
                        <li>Sales (attempts until r sales made)</li>
                        <li>Epidemiology (contacts until r infections)</li>
                    </ul>
                    </div>

                    <h5>🔗 Multivariate Hypergeometric Distribution</h5>
                    <div class="formula">P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [∏ C(Kᵢ,kᵢ)] / C(N,n)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Elections with multiple candidate categories</li>
                        <li>Contingency table analysis</li>
                        <li>Multivariate sampling from categorized populations</li>
                        <li>Genetics and population studies</li>
                    </ul>
                    </div>

                    <h5>🎭 Multinomial Distribution</h5>
                    <div class="formula">P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [n! / (k₁!k₂!...kₘ!)] × p₁^k₁ × p₂^k₂ × ... × pₘ^kₘ</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Election results across multiple parties</li>
                        <li>Consumer choice modeling</li>
                        <li>Marketing response categorization</li>
                        <li>Genetic inheritance patterns</li>
                    </ul>
                    </div>

                    <h4>📋 Key Statistical Concepts</h4>
                    <ul>
                        <li><strong>Parameters vs Statistics:</strong> Parameters describe population distributions, statistics describe samples</li>
                        <li><strong>Maximum Likelihood Estimation (MLE):</strong> Method for estimating distribution parameters from data</li>
                        <li><strong>Goodness-of-Fit Tests:</strong> Kolmogorov-Smirnov test assesses how well data fits a distribution</li>
                        <li><strong>Central Limit Theorem:</strong> Sample means approach normal distribution regardless of parent distribution</li>
                        <li><strong>Law of Large Numbers:</strong> Sample statistics converge to population parameters with increasing sample size</li>
                    </ul>

                    <h4>🔍 Choosing the Right Distribution</h4>
                    <ul>
                        <li><strong>Data Type:</strong> Continuous/interval data → continuous distributions, discrete/count data → discrete distributions</li>
                        <li><strong>Data Range:</strong> Bounded (0-1) data → Beta, positive only → Gamma/Exponential, unlimited → Normal</li>
                        <li><strong>Shape Characteristics:</strong> Symmetry (Normal), right-skewness (Gamma, Weibull), heavy tails (t-distribution)</li>
                        <li><strong>Subject Matter Knowledge:</strong> Domain expertise often guides choice (e.g., Pareto for wealth distributions)</li>
                        <li><strong>Statistical Tests:</strong> Use goodness-of-fit tests to validate distribution assumptions</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
// Distribution definitions with parameters and explanations
        const distributions = {
            normal: {
                name: "Normal Distribution",
                params: [
                    { name: "μ (mean)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "σ (standard deviation)", id: "sigma", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Normal distribution, discovered by Carl Friedrich Gauss, is the cornerstone of statistical inference and the Central Limit Theorem. It describes phenomena where many small, independent random effects combine additively.</p>

                    <div class="formula">
                    f(x; μ, σ) = (1/(σ√(2π))) * exp(-((x-μ)²)/(2σ²))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (mean)</strong>: Location parameter - determines the center/peak of the distribution</li>
                        <li><strong>σ (standard deviation)</strong>: Scale parameter - controls the spread/variance (σ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Measurement Science</strong>: Heights, weights, IQ scores, blood pressure</li>
                        <li><strong>Quality Control</strong>: Manufacturing tolerances, product specifications</li>
                        <li><strong>Finance</strong>: Stock returns (under log-normal assumptions), option pricing</li>
                        <li><strong>Natural Phenomena</strong>: Light intensity, particle velocities, astronomical measurements</li>
                        <li><strong>Psychometrics</strong>: Test scores, reaction times, cognitive abilities</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Symmetric with mean = median = mode = μ</li>
                        <li>68-95-99.7 rule: 68% within 1σ, 95% within 1.96σ, 99.7% within 3σ</li>
                        <li>Inflection points at μ ± σ</li>
                        <li>Maximum entropy distribution for given mean and variance</li>
                        <li>Stable under addition (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Historical Context:</strong> First derived by Abraham de Moivre in 1733 for binomial approximations. Gauss proved its universal importance in the theory of errors.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    // Using approximation for normal CDF
                    const mu = params.mu, sigma = params.sigma;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: mu,
                        variance: sigma * sigma,
                        skewness: 0,
                        kurtosis: 0,
                        median: mu,
                        mode: mu
                    };
                }
            },

            binomial: {
                name: "Binomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 100, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.5, min: 0, max: 1, step: 0.01 }
                ],
                explanation: `
                    <p>The Binomial distribution was developed by Jacob Bernoulli and is one of the earliest distributions in probability theory. It models scenarios where we conduct a fixed number of independent trials, each having exactly two possible outcomes (success/failure).</p>

                    <div class="formula">
                    P(X = k) = C(n,k) × p^k × (1-p)^(n-k)
                    </div>

                    <div class="formula" style="margin-top: 10px;">
                    C(n,k) = n! / (k! × (n-k)!)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n (number of trials)</strong>: Fixed sample size (must be a positive integer)</li>
                        <li><strong>p (success probability)</strong>: Probability of success on any single trial (0 ≤ p ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Clinical Trials</strong>: Number of patients who respond to a treatment</li>
                        <li><strong>Quality Assurance</strong>: Proportion of defective products in a batch</li>
                        <li><strong>Elections</strong>: Number of votes for a candidate in exit polls</li>
                        <li><strong>A/B Testing</strong>: Conversion rates in website optimization</li>
                        <li><strong>Risk Assessment</strong>: Number of claims in an insurance portfolio</li>
                        <li><strong>Biology</strong>: Number of males in a litter of fixed size</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Mean = np, Variance = np(1-p)</li>
                        <li>Symmetric when p = 0.5, right-skewed when p < 0.5, left-skewed when p > 0.5</li>
                        <li>Maximum value is n (all successes), minimum is 0 (no successes)</li>
                        <li>Approaches Poisson distribution as n→∞ and p→0 (with λ = np fixed)</li>
                        <li>Approaches Normal distribution as n→∞ (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Theoretical Foundations:</strong> Based on Bernoulli trials with independence assumption. Each trial must be identical and the outcome probabilities must remain constant across trials.</p>

                    <p><strong>Assumptions:</strong> Fixed number of trials, independence between trials, constant success probability, only two possible outcomes per trial.</p>
                `,
                pmf: (k, params) => {
                    const n = params.n, p = params.p;
                    if (k < 0 || k > n) return 0;
                    return math.combinations(n, k) * Math.pow(p, k) * Math.pow(1-p, n-k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const n = params.n, p = params.p;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p),
                        skewness: (1 - 2*p) / Math.sqrt(n * p * (1-p)),
                        kurtosis: (1 - 6*p*(1-p)) / (n * p * (1-p)),
                        median: Math.round(n * p),
                        mode: Math.round((n + 1) * p)
                    };
                }
            },

            poisson: {
                name: "Poisson Distribution",
                params: [
                    { name: "λ (rate parameter)", id: "lambda", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Poisson distribution models the number of events occurring in a fixed interval of time or space.</p>

                    <div class="formula">
                    P(X = k) = e^(-λ) * λ^k / k!
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>λ (lambda)</strong>: Average rate of events (λ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of customer arrivals per hour</li>
                        <li>Number of defects in a product</li>
                        <li>Number of phone calls received</li>
                        <li>Number of accidents at an intersection</li>
                        <li>Radioactive decay events</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete distribution. Mean = Variance = λ. Right-skewed for small λ, approaches normal as λ increases.</p>
                `,
                pmf: (k, params) => {
                    const lambda = params.lambda;
                    if (k < 0) return 0;
                    return Math.exp(-lambda) * Math.pow(lambda, k) / math.factorial(k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const lambda = params.lambda;
                    return {
                        mean: lambda,
                        variance: lambda,
                        skewness: 1/Math.sqrt(lambda),
                        kurtosis: 1/lambda,
                        median: Math.round(lambda + 1/3 - 0.02/lambda),
                        mode: Math.floor(lambda)
                    };
                }
            },

            beta: {
                name: "Beta Distribution",
                params: [
                    { name: "α (shape parameter)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "β (shape parameter)", id: "beta", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Beta distribution models random variables whose values are constrained to a finite interval [0,1].</p>

                    <div class="formula">
                    f(x) = (x^(α-1) * (1-x)^(β-1)) / B(α,β)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>α (alpha)</strong>: Shape parameter (α > 0)</li>
                        <li><strong>β (beta)</strong>: Shape parameter (β > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Proportions and rates between 0 and 1</li>
                        <li>Bayesian statistics (conjugate prior for Bernoulli)</li>
                        <li>Time allocation between activities</li>
                        <li>Quality control (percentage defective)</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shapes from uniform to U-shaped. Mean = α/(α+β), Variance = αβ/((α+β)²(α+β+1)).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0 || x > 1) return 0;
                    const alpha = params.alpha, beta = params.beta;
                    return Math.pow(x, alpha-1) * Math.pow(1-x, beta-1) / math.beta(alpha, beta);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    if (x >= 1) return 1;
                    // Approximate using beta incomplete function
                    const alpha = params.alpha, beta = params.beta;
                    return math.betainc(x, alpha, beta);
                },
                stats: (params) => {
                    const alpha = params.alpha, beta = params.beta;
                    const total = alpha + beta;
                    return {
                        mean: alpha / total,
                        variance: (alpha * beta) / (total * total * (total + 1)),
                        skewness: (2 * (beta - alpha) * Math.sqrt(total + 1)) / ((total + 2) * Math.sqrt(alpha * beta)),
                        kurtosis: (6 * (alpha - beta) * (alpha - beta) * (total + 1) - alpha * beta * (total + 2)) / (alpha * beta * (total + 2) * (total + 3)),
                        median: (alpha - 1/3) / (total - 2/3), // approximation
                        mode: (alpha - 1) / (total - 2)
                    };
                }
            },

            gamma: {
                name: "Gamma Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "θ (scale)", id: "theta", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Gamma distribution generalizes the exponential distribution and is used for positive continuous variables.</p>

                    <div class="formula">
                    f(x) = (x^(k-1) * e^(-x/θ)) / (θ^k * Γ(k))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>θ (scale)</strong>: Scale parameter (θ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Waiting times between Poisson events</li>
                        <li>Life testing and reliability engineering</li>
                        <li>Size of insurance claims</li>
                        <li>Queueing theory</li>
                        <li>Bayesian statistics (conjugate prior)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal as k increases. Mean = kθ, Variance = kθ².</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, theta = params.theta;
                    return Math.pow(x, k-1) * Math.exp(-x/theta) / (Math.pow(theta, k) * math.gamma(k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, theta = params.theta;
                    return math.gammainc(k, x/theta);
                },
                stats: (params) => {
                    const k = params.k, theta = params.theta;
                    return {
                        mean: k * theta,
                        variance: k * theta * theta,
                        skewness: 2 / Math.sqrt(k),
                        kurtosis: 6 / k,
                        median: theta * (k - 1/3), // approximation
                        mode: theta * (k - 1)
                    };
                }
            },

            geometric: {
                name: "Geometric Distribution",
                params: [
                    { name: "p (success probability)", id: "p", default: 0.3, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Geometric distribution models the number of trials needed to get the first success in Bernoulli trials.</p>

                    <div class="formula">
                    P(X = k) = (1-p)^(k-1) * p
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>p</strong>: Probability of success in each trial (0 < p ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of attempts needed to succeed</li>
                        <li>Reliability engineering (time to first failure)</li>
                        <li>Customer service (calls until first success)</li>
                        <li>Quality control (items inspected until first defect)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Memoryless property (like exponential distribution). Mean = 1/p, Variance = (1-p)/p².</p>
                `,
                pmf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return Math.pow(1-p, k-1) * p;
                },
                cdf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return 1 - Math.pow(1-p, k);
                },
                stats: (params) => {
                    const p = params.p;
                    return {
                        mean: 1/p,
                        variance: (1-p)/(p*p),
                        skewness: (2-p)/Math.sqrt(1-p),
                        kurtosis: (p*p - 6*p + 6)/(1-p),
                        median: Math.ceil(-Math.log(2)/Math.log(1-p)),
                        mode: 1
                    };
                }
            },

            hypergeometric: {
                name: "Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 2, max: 100, step: 1 },
                    { name: "K (success states)", id: "K", default: 7, min: 0, max: 20, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The Hypergeometric distribution models sampling without replacement from a finite population.</p>

                    <div class="formula">
                    P(X = k) = [C(K,k) × C(N-K,n-k)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size (N ≥ 1)</li>
                        <li><strong>K</strong>: Number of successes in population (0 ≤ K ≤ N)</li>
                        <li><strong>n</strong>: Sample size without replacement (0 < n ≤ N)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (sampling from production lots)</li>
                        <li>Election auditing (sample verification)</li>
                        <li>Card games and lottery draws</li>
                        <li>Biological sampling (capture-recapture)</li>
                        <li>Mining and mineral exploration</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete, mean = nK/N, variance = nK/N(1-K/N)(N-n)/(N-1). Approaches binomial as N→∞.</p>
                `,
                pmf: (k, params) => {
                    const N = params.N, K = params.K, n = params.n;
                    if (k < Math.max(0, n - (N - K)) || k > Math.min(n, K)) return 0;
                    const comb1 = math.combinations(K, k);
                    const comb2 = math.combinations(N - K, n - k);
                    const comb3 = math.combinations(N, n);
                    return (comb1 * comb2) / comb3;
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const N = params.N, K = params.K, n = params.n;
                    const p = K / N;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p) * (N - n) / (N - 1),
                        skewness: ((N - 2*K) * Math.sqrt(N - 1) * Math.sqrt(N - n)) / (Math.sqrt(n * K * (N - K) * (N - n)) * Math.sqrt(N - 2)),
                        kurtosis: 'Complex calculation needed',
                        median: Math.round(n * K / N),
                        mode: Math.round((n + 1) * (K + 1) / (N + 2))
                    };
                }
            },

            multivariate: {
                name: "Multivariate Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 5, max: 100, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution used when there are multiple categories.</p>

                    <div class="formula">
                    P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [∏ C(Kᵢ,kᵢ)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size</li>
                        <li><strong>n</strong>: Sample size</li>
                        <li><strong>Kⱼ</strong>: Size of each category in population</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election sampling with multiple parties</li>
                        <li>Contingency table analysis</li>
                        <li>Multiple classification sampling</li>
                        <li>Genetics and population studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multidimensional generalization of hypergeometric. Used in multivariate statistics and experimental design.</p>
                `,
                // Note: This is a simplification - true multivariate hypergeometric would need category sizes
                pmf: (k, params) => {
                    // This is a placeholder - multivariate hypergeometric is complex
                    return 0.1; // Placeholder value
                },
                cdf: (k, params) => {
                    // Approximation for demonstration
                    return 0.5;
                },
                stats: (params) => {
                    const N = params.N, n = params.n;
                    return {
                        mean: 'Multi-dimensional',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Multi-dimensional'
                    };
                }
            },

            negativebinomial: {
                name: "Negative Binomial Distribution",
                params: [
                    { name: "r (successes)", id: "r", default: 5, min: 1, max: 20, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.4, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Negative Binomial distribution models the number of trials needed to achieve a specified number of successes.</p>

                    <div class="formula">
                    P(X = k) = C(k-1,r-1) × p^r × (1-p)^(k-r)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>r</strong>: Number of successes required (r ≥ 1)</li>
                        <li><strong>p</strong>: Probability of success on each trial (0 < p < 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (trials until r defects found)</li>
                        <li>Sales (attempts until r sales made)</li>
                        <li>Sports (games until r wins)</li>
                        <li>Reliability (failures until r successful tests)</li>
                        <li>Epidemiology (contacts until r infections)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Overdispersion compared to Poisson. Mean = r/p, Variance = r(1-p)/p². Special case of Poisson when r=1 (geometric).</p>
                `,
                pmf: (k, params) => {
                    const r = params.r, p = params.p;
                    if (k < r) return 0;
                    return math.combinations(k-1, r-1) * Math.pow(p, r) * Math.pow(1-p, k-r);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = params.r; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const r = params.r, p = params.p;
                    return {
                        mean: r / p,
                        variance: r * (1 - p) / (p * p),
                        skewness: (2 - p) / Math.sqrt(r * (1 - p)),
                        kurtosis: (p * p - 6 * p + 6) / (r * (1 - p)),
                        median: 'Approximation needed',
                        mode: Math.floor((r - 1) * (1 - p) / p) + r
                    };
                }
            },

            multinomial: {
                name: "Multinomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 50, step: 1 }
                ],
                explanation: `
                    <p>The Multinomial distribution is a generalization of the binomial distribution for experiments with more than two possible outcomes.</p>

                    <div class="formula">
                    P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [n! / (k₁!k₂!...kₘ!)] × p₁^k₁ × p₂^k₂ × ... × pₘ^kₘ
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n</strong>: Number of independent trials</li>
                        <li><strong>pⱼ</strong>: Probability of each outcome category (∑pⱼ = 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election results across multiple parties</li>
                        <li>Marketing response categories</li>
                        <li>Genetic inheritance patterns</li>
                        <li>Consumer preference studies</li>
                        <li>Disease classification studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multivariate generalization of binomial. Mean vector = n*p, covariance matrix = n*diag(p) - n*p*p^T.</p>
                `,
                // Note: This is highly simplified - multinomial distribution is complex for visualization
                pmf: (k, params) => {
                    // Placeholder - real multinomial is multivariate
                    return 0.1;
                },
                cdf: (k, params) => {
                    return 0.5;
                },
                stats: (params) => {
                    const n = params.n;
                    return {
                        mean: 'Vector-valued',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Complex'
                    };
                }
            },

            uniform: {
                name: "Continuous Uniform Distribution",
                params: [
                    { name: "a (min)", id: "a", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (max)", id: "b", default: 1, min: -10, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Continuous Uniform distribution has constant probability density over a finite interval.</p>

                    <div class="formula">
                    f(x) = 1/(b-a)  for a ≤ x ≤ b
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>a</strong>: Minimum value</li>
                        <li><strong>b</strong>: Maximum value (b > a)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Random number generation</li>
                        <li>Round-off errors</li>
                        <li>Physical measurements with limited precision</li>
                        <li>Simulation modeling</li>
                        <li>Bayesian prior (lack of information)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Rectangular shape. Mean = (a+b)/2, Variance = (b-a)²/12. No mode (every value equally likely).</p>
                `,
                pdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x < a || x > b || a >= b) return 0;
                    return 1/(b-a);
                },
                cdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x <= a) return 0;
                    if (x >= b) return 1;
                    return (x - a)/(b - a);
                },
                stats: (params) => {
                    const a = params.a, b = params.b;
                    const range = b - a;
                    return {
                        mean: (a + b) / 2,
                        variance: range * range / 12,
                        skewness: 0,
                        kurtosis: -6/5,
                        median: (a + b) / 2,
                        mode: 'No unique mode (uniform)'
                    };
                }
            },

            studentt: {
                name: "Student-t Distribution",
                params: [
                    { name: "ν (degrees of freedom)", id: "df", default: 5, min: 0.1, max: 30, step: 0.1 }
                ],
                explanation: `
                    <p>The Student-t distribution arises from estimating the mean of a normally distributed population with unknown variance.</p>

                    <div class="formula">
                    f(x) = Γ((ν+1)/2) / (√(νπ) * Γ(ν/2)) * (1 + x²/ν)^(-(ν+1)/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>ν (degrees of freedom)</strong>: Shape parameter (ν > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Statistical inference (t-tests)</li>
                        <li>Confidence intervals with small samples</li>
                        <li>Regression analysis</li>
                        <li>Bayesian statistics</li>
                        <li>Financial modeling (heavy tails)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric, bell-shaped but with heavier tails than normal. As ν→∞, approaches normal distribution. Mean = 0 for ν > 1, undefined otherwise.</p>
                `,
                pdf: (x, params) => {
                    const df = params.df;
                    const num = math.gamma((df + 1)/2);
                    const den = Math.sqrt(df * Math.PI) * math.gamma(df/2);
                    const factor = Math.pow(1 + x*x/df, -(df+1)/2);
                    return (num / den) * factor;
                },
                cdf: (x, params) => {
                    // Approximation for t-distribution CDF
                    const df = params.df;
                    if (df <= 0) return 0.5;

                    const z = x / Math.sqrt(1 + x*x/df);
                    const normal_cdf = 0.5 * (1 + math.erf(z/Math.sqrt(2)));
                    return normal_cdf;
                },
                stats: (params) => {
                    const df = params.df;
                    return {
                        mean: df > 1 ? 0 : 'Undefined',
                        variance: df > 2 ? df/(df-2) : 'Undefined',
                        skewness: df > 3 ? 0 : 'Undefined',
                        kurtosis: df > 4 ? 6/(df-4) : 'Undefined',
                        median: 0,
                        mode: 0
                    };
                }
            },

            weibull: {
                name: "Weibull Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 1.5, min: 0.1, max: 10, step: 0.1 },
                    { name: "λ (scale)", id: "lambda", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Weibull distribution is widely used in reliability engineering and survival analysis.</p>

                    <div class="formula">
                    f(x) = (k/λ) * (x/λ)^(k-1) * exp(-(x/λ)^k)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>λ (scale)</strong>: Scale parameter (λ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Reliability engineering (failure times)</li>
                        <li>Survival analysis</li>
                        <li>Wind speed modeling</li>
                        <li>Material fatigue life</li>
                        <li>Product lifetime analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shape - exponential when k=1, right-skewed for k<1, approaches normal for large k. Mean = λΓ(1+1/k), Variance = λ²[Γ(1+2/k) - Γ²(1+1/k)].</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return (k/lambda) * Math.pow(x/lambda, k-1) * Math.exp(-Math.pow(x/lambda, k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return 1 - Math.exp(-Math.pow(x/lambda, k));
                },
                stats: (params) => {
                    const k = params.k, lambda = params.lambda;
                    return {
                        mean: lambda * math.gamma(1 + 1/k),
                        variance: lambda*lambda * (math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2)),
                        skewness: (math.gamma(1 + 3/k) - 3*math.gamma(1 + 1/k)*math.gamma(1 + 2/k) + 2*Math.pow(math.gamma(1 + 1/k), 3)) / Math.pow(math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2), 1.5),
                        kurtosis: 'Complex calculation needed',
                        median: lambda * Math.pow(Math.log(2), 1/k),
                        mode: lambda * Math.pow((k-1)/k, 1/k)
                    };
                }
            },

            pareto: {
                name: "Pareto Distribution",
                params: [
                    { name: "α (shape)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "x₀ (scale)", id: "x0", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Pareto distribution models phenomena where a small number of events account for a large proportion of outcomes.</p>

                    <div class="formula">
                    f(x) = α x₀^α / x^(α+1)  for x ≥ x₀
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>α (shape)</strong>: Shape parameter (α > 0)</li>
                        <li><strong>x₀ (scale)</strong>: Minimum value (x₀ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Income distribution (80/20 rule)</li>
                        <li>City population sizes</li>
                        <li>File size distribution</li>
                        <li>Insurance claims</li>
                        <li>Ecosystem species abundance</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Heavy tail, used in power-law phenomena. Mean = αx₀/(α-1) for α>1. Variance undefined for α≤2.</p>
                `,
                pdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x < x0) return 0;
                    return alpha * Math.pow(x0/alpha, alpha) / Math.pow(x, alpha + 1);
                },
                cdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x <= x0) return 0;
                    return 1 - Math.pow(x0/x, alpha);
                },
                stats: (params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    return {
                        mean: alpha > 1 ? (alpha * x0) / (alpha - 1) : 'Undefined',
                        variance: alpha > 2 ? (x0*x0 * alpha) / ((alpha - 1)*(alpha - 1) * (alpha - 2)) : 'Undefined',
                        skewness: alpha > 3 ? (2*(alpha + 1)/(alpha - 3)) * Math.sqrt((alpha - 2)/alpha) : 'Undefined',
                        kurtosis: 'Complex calculation needed',
                        median: x0 * Math.pow(2, 1/alpha),
                        mode: x0
                    };
                }
            },

            logistic: {
                name: "Logistic Distribution",
                params: [
                    { name: "μ (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "s (scale)", id: "s", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Logistic distribution is used in growth models and as a smooth approximation to the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/s) * exp(-(x-μ)/s) / (1 + exp(-(x-μ)/s))²
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (location)</strong>: Location parameter</li>
                        <li><strong>s (scale)</strong>: Scale parameter (s > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Growth models</li>
                        <li>Regression analysis</li>
                        <li>Neural networks (sigmoid activation)</li>
                        <li>Demographic modeling</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric distribution with heavier tails than normal. Mean = μ, Variance = s²π²/3. Used as link function in logistic regression.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    const exp_term = Math.exp(-(x - mu) / s);
                    return (1/s) * exp_term / Math.pow(1 + exp_term, 2);
                },
                cdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    return 1 / (1 + Math.exp(-(x - mu) / s));
                },
                stats: (params) => {
                    const mu = params.mu, s = params.s;
                    return {
                        mean: mu,
                        variance: s * s * Math.PI * Math.PI / 3,
                        skewness: 0,
                        kurtosis: 6/5,
                        median: mu,
                        mode: mu
                    };
                }
            },

            laplace: {
                name: "Laplace Distribution",
                params: [
                    { name: "μ (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (scale)", id: "b", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Laplace distribution (also called double exponential) has heavier tails than the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/(2b)) * exp(-|x-μ|/b)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (location)</strong>: Location parameter</li>
                        <li><strong>b (scale)</strong>: Scale parameter (b > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Modeling absolute deviations</li>
                        <li>Robust statistics</li>
                        <li>Signal processing</li>
                        <li>Finance (heavy tail modeling)</li>
                        <li>Atmospheric data analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric with sharper peak and heavier tails than normal. Mean = μ, Variance = 2b². Maximum entropy distribution for given mean absolute deviation.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    return (1/(2*b)) * Math.exp(-Math.abs(x - mu)/b);
                },
                cdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    if (x < mu) {
                        return 0.5 * Math.exp((x - mu)/b);
                    } else {
                        return 1 - 0.5 * Math.exp((mu - x)/b);
                    }
                },
                stats: (params) => {
                    const mu = params.mu, b = params.b;
                    return {
                        mean: mu,
                        variance: 2 * b * b,
                        skewness: 0,
                        kurtosis: 3,
                        median: mu,
                        mode: mu
                    };
                }
            },

            chisquared: {
                name: "Chi-Squared Distribution",
                params: [
                    { name: "k (degrees of freedom)", id: "k", default: 5, min: 0.1, max: 20, step: 0.1 }
                ],
                explanation: `
                    <p>The Chi-Squared distribution arises from the sum of squares of independent standard normal random variables.</p>

                    <div class="formula">
                    f(x) = (1/(2^(k/2) * Γ(k/2))) * x^(k/2 - 1) * exp(-x/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (degrees of freedom)</strong>: Shape parameter (k > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Chi-squared tests for independence</li>
                        <li>Confidence interval construction</li>
                        <li>Goodness-of-fit tests</li>
                        <li>Variance estimation</li>
                        <li>Process capability analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal for large k. Mean = k, Variance = 2k. Support on (0,∞).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k;
                    return (1 / (Math.pow(2, k/2) * math.gamma(k/2))) * Math.pow(x, k/2 - 1) * Math.exp(-x/2);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k;
                    return math.gammainc(k/2, x/2);
                },
                stats: (params) => {
                    const k = params.k;
                    return {
                        mean: k,
                        variance: 2 * k,
                        skewness: Math.sqrt(8/k),
                        kurtosis: 12/k,
                        median: k * Math.pow(1 - 2/(9*k), 3), // approximation
                        mode: k - 2
                    };
                }
            },

            fdist: {
                name: "F-Distribution (Snedecor F)",
                params: [
                    { name: "d₁ (numerator df)", id: "df1", default: 5, min: 0.1, max: 30, step: 0.1 },
                    { name: "d₂ (denominator df)", id: "df2", default: 10, min: 0.1, max: 30, step: 0.1 }
                ],
                explanation: `
                    <p>The F-distribution (also known as Snedecor F-distribution or Fisher-Snedecor distribution) arises in the testing of whether two observed samples have the same variance.</p>

                    <div class="formula">
                    f(x) = (Γ((d₁+d₂)/2) / (Γ(d₁/2) * Γ(d₂/2))) * (d₁/d₂)^(d₁/2) * x^(d₁/2-1) * (1 + (d₁/d₂)x)^(-(d₁+d₂)/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>d₁ (degrees of freedom numerator)</strong>: Shape parameter (d₁ > 0)</li>
                        <li><strong>d₂ (degrees of freedom denominator)</strong>: Shape parameter (d₂ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>ANOVA (Analysis of Variance)</li>
                        <li>F-test for equality of variances</li>
                        <li>Regression analysis (F-test)</li>
                        <li>General linear models</li>
                        <li>Quality control (variance testing)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, continuous, support on (0,∞). Mean = d₂/(d₂-2) for d₂>2. Variance = 2d₂²(d₁+d₂-2)/[d₁(d₂-2)²(d₂-4)] for d₂>4.</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    const num = math.gamma((df1+df2)/2) * Math.pow(df1/df2, df1/2) * Math.pow(x, df1/2 - 1);
                    const den = math.gamma(df1/2) * math.gamma(df2/2) * Math.pow(1 + (df1/df2)*x, (df1+df2)/2);
                    return num / den;
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    // Approximation using beta function relationship
                    const z = (df1 * x) / (df1 * x + df2);
                    return math.betainc(z, df1/2, df2/2);
                },
                stats: (params) => {
                    const df1 = params.df1, df2 = params.df2;
                    return {
                        mean: df2 > 2 ? df2 / (df2 - 2) : 'Undefined',
                        variance: df2 > 4 ? (2 * df2 * df2 * (df1 + df2 - 2)) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4)) : 'Undefined',
                        skewness: 'Complex calculation needed',
                        kurtosis: 'Complex calculation needed',
                        median: 'Approximation needed',
                        mode: (df1 - 2)/df1 * df2/(df2 + 2) // approximation
                    };
                }
            },

            bivariate: {
                name: "Bivariate Normal Distribution",
                params: [
                    { name: "μ₁ (mean X)", id: "mu1", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "μ₂ (mean Y)", id: "mu2", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "σ₁ (std X)", id: "sigma1", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "σ₂ (std Y)", id: "sigma2", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "ρ (correlation)", id: "rho", default: 0.5, min: -0.99, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The bivariate normal distribution is a generalization of the univariate normal distribution to two dimensions. It describes the joint behavior of two normally distributed random variables.</p>

                    <div class="formula">
                    f(x,y) = (1/(2πσ₁σ₂√(1-ρ²))) * exp[-1/(2(1-ρ²))] * [(x-μ₁)²/σ₁² - 2ρ(x-μ₁)(y-μ₂)/(σ₁σ₂) + (y-μ₂)²/σ₂²]
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ₁, μ₂</strong>: Means for X and Y variables</li>
                        <li><strong>σ₁, σ₂</strong>: Standard deviations for X and Y variables</li>
                        <li><strong>ρ</strong>: Correlation coefficient between X and Y (-1 ≤ ρ ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Multivariate analysis</li>
                        <li>Portfolio optimization (asset returns)</li>
                        <li>Biological measurements (height & weight)</li>
                        <li>Economic indicators</li>
                        <li>Quality control (multiple measurements)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Elliptical contours, marginal distributions are normal, conditional distributions are normal. Covariance = ρσ₁σ₂.</p>
                `,
                // Note: Bivariate normal is 2D - we'll provide marginal distributions for 1D plots
                pdf: (x, params) => {
                    // For visualization, we'll show the marginal distribution for X
                    const mu = params.mu1, sigma = params.sigma1;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    const mu = params.mu1, sigma = params.sigma1;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    return {
                        mean: `${params.mu1} (X), ${params.mu2} (Y)`,
                        variance: `${params.sigma1}² (X), ${params.sigma2}² (Y)`,
                        skewness: '0 (for both marginals)',
                        kurtosis: '0 (for both marginals)',
                        median: `${params.mu1} (X), ${params.mu2} (Y)`,
                        mode: `${params.mu1} (X), ${params.mu2} (Y)`
                    };
                }
            },

            lognormal: {
                name: "Log-Normal Distribution",
                params: [
                    { name: "μ (log mean)", id: "mu", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "σ (log std dev)", id: "sigma", default: 1, min: 0.1, max: 3, step: 0.1 }
                ],
                explanation: `
                    <p>The log-normal distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed. It arises when the logarithm of a quantity is normally distributed.</p>

                    <div class="formula">
                    f(x) = (1/(xσ√(2π))) * exp[-(ln(x)-μ)²/(2σ²)] for x > 0
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (log mean)</strong>: Mean of the logarithmic values</li>
                        <li><strong>σ (log std dev)</strong>: Standard deviation of the logarithmic values</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Stock prices (Black-Scholes model)</li>
                        <li>Particle sizes in materials</li>
                        <li>Income distributions</li>
                        <li>Survival times with multiplicative effects</li>
                        <li>Environmental concentrations</li>
                        <li>Reliability (failure times with multiple factors)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, support on (0,∞). Mean = exp(μ + σ²/2), Variance = exp(2μ + σ²)(exp(σ²) - 1). Median = exp(μ).</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const logx = Math.log(x);
                    return (1 / (x * sigma * Math.sqrt(2 * Math.PI))) *
                           Math.exp(-Math.pow(logx - mu, 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const z = (Math.log(x) - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: Math.exp(mu + sigma * sigma / 2),
                        variance: Math.exp(2*mu + sigma*sigma) * (Math.exp(sigma*sigma) - 1),
                        skewness: (Math.exp(sigma*sigma) + 2) * Math.sqrt(Math.exp(sigma*sigma) - 1),
                        kurtosis: Math.exp(4*sigma*sigma) + 2*Math.exp(3*sigma*sigma) + 3*Math.exp(2*sigma*sigma) - 6,
                        median: Math.exp(mu),
                        mode: Math.exp(mu - sigma*sigma)
                    };
                }
            }
        };

// Global variables for data analysis
let charts = {};
let currentDistribution = null;

// Distribution definitions with parameters and explanations
function showTab(tabName) {
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });

    document.querySelectorAll('.nav-tabs button').forEach(btn => {
        btn.classList.remove('active');
    });

    document.getElementById(tabName).classList.add('active');
    event.target.classList.add('active');
}

function loadDistribution() {
    const select = document.getElementById('distributionSelect');
    const distName = select.value;

    if (!distName) return;

    currentDistribution = distributions[distName];
    document.getElementById('distTitle').textContent = currentDistribution.name;
    renderParameters();
    updateStatistics();
    renderCharts();
    renderExplanation();
}

function renderParameters() {
    const container = document.getElementById('paramsContainer');
    container.innerHTML = '';

    currentDistribution.params.forEach(param => {
        const control = document.createElement('div');
        control.className = 'param-control';
        control.innerHTML = `
            <label for="${param.id}">${param.name}</label>
            <input type="number" id="${param.id}" value="${param.default}"
                   min="${param.min}" max="${param.max}" step="${param.step}"
                   oninput="updateStatistics(); renderCharts()">
        `;
        container.appendChild(control);
    });
}

function getCurrentParams() {
    const params = {};
    if (!currentDistribution) return params;

    currentDistribution.params.forEach(param => {
        const input = document.getElementById(param.id);
        params[param.id] = parseFloat(input ? input.value : param.default) || param.default;
    });
    return params;
}

function updateStatistics() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    try {
        const stats = currentDistribution.stats(params);
        const container = document.getElementById('statsContainer');
        container.innerHTML = `
            <div class="stat-card">
                <div class="value">${stats.mean.toFixed ? stats.mean.toFixed(3) : stats.mean}</div>
                <div class="label">Mean (μ)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.variance.toFixed ? stats.variance.toFixed(3) : stats.variance}</div>
                <div class="label">Variance (σ²)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.skewness.toFixed ? stats.skewness.toFixed(3) : stats.skewness}</div>
                <div class="label">Skewness</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.kurtosis.toFixed ? stats.kurtosis.toFixed(3) : stats.kurtosis}</div>
                <div class="label">Kurtosis</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.median.toFixed ? stats.median.toFixed(3) : stats.median}</div>
                <div class="label">Median</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.mode.toFixed ? stats.mode.toFixed(3) : stats.mode}</div>
                <div class="label">Mode</div>
            </div>
        `;
    } catch (e) {
        console.error('Error calculating statistics:', e);
        document.getElementById('statsContainer').innerHTML = '<div class="error">Error calculating statistics</div>';
    }
}

function renderCharts() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    const isDiscrete = currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') ||
                      currentDistribution.name.includes('Geometric') || currentDistribution.name.includes('Hypergeometric') ||
                      currentDistribution.name.includes('Negative Binomial');

    let xMin, xMax, step;
    let xValues = [], pdfValues = [], cdfValues = [];

    try {
        if (isDiscrete) {
            // Discrete distributions: use integer values
            xMin = 0;
            xMax = currentDistribution.name.includes('Binomial') ? params.n :
                   currentDistribution.name.includes('Geometric') ? Math.min(params.lambda * 3, 20) :
                   currentDistribution.name.includes('Hypergeometric') ? Math.min(params.n, 20) :
                   Math.min(params.lambda * 3, params.lambda * 2 + 10);

            for (let x = xMin; x <= xMax; x++) {
                xValues.push(x);
                pdfValues.push(currentDistribution.pmf ? currentDistribution.pmf(x, params) : 0);
                cdfValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
            }
        } else {
            // Continuous distributions: use smooth curve
            if (currentDistribution.name.includes('Beta') || currentDistribution.name.includes('Uniform')) {
                xMin = currentDistribution.name.includes('Uniform') ? params.a : 0;
                xMax = currentDistribution.name.includes('Uniform') ? params.b : 1;
                step = 0.02;
            } else {
                const range = Math.max(Math.abs(params.mu || 0) + 3 * Math.abs(params.sigma || 1), 5);
                xMin = -range;
                xMax = range;
                step = Math.max(range / 50, 0.1);
            }

            for (let x = xMin; x <= xMax; x += step) {
                xValues.push(Math.round(x * 100) / 100);
                pdfValues.push(currentDistribution.pdf ? currentDistribution.pdf(x, params) : 0);
                cdfValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
            }
        }

        // PDF Chart
        const pdfCtx = document.getElementById('pdfChart').getContext('2d');
        if (charts.pdf) charts.pdf.destroy();
        charts.pdf = new Chart(pdfCtx, {
            type: isDiscrete ? 'bar' : 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: isDiscrete ? 'Probability Mass' : 'Probability Density',
                    data: pdfValues,
                    borderColor: isDiscrete ? '#10b981' : '#10b981',
                    backgroundColor: isDiscrete ? 'rgba(16, 185, 129, 0.6)' : 'rgba(16, 185, 129, 0.1)',
                    fill: !isDiscrete,
                    borderWidth: 2,
                    pointRadius: isDiscrete ? 0 : 0,
                    pointHoverRadius: isDiscrete ? 4 : 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'x' },
                        type: isDiscrete ? 'category' : 'linear'
                    },
                    y: {
                        title: { display: true, text: isDiscrete ? 'Probability' : 'Density' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    title: { display: true, text: isDiscrete ? 'Probability Mass Function' : 'Probability Density Function' }
                }
            }
        });

        // CDF Chart
        const cdfCtx = document.getElementById('cdfChart').getContext('2d');
        if (charts.cdf) charts.cdf.destroy();
        charts.cdf = new Chart(cdfCtx, {
            type: 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: 'Cumulative Probability',
                    data: cdfValues,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    fill: true,
                    borderWidth: 2,
                    pointRadius: isDiscrete ? 3 : 0,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'x' } },
                    y: {
                        title: { display: true, text: 'Cumulative Probability' },
                        min: 0, max: 1
                    }
                },
                plugins: {
                    title: { display: true, text: 'Cumulative Distribution Function' }
                }
            }
        });
    } catch (e) {
        console.error('Error rendering charts:', e);
        // Clear canvases on error
        const pdfCanvas = document.getElementById('pdfChart');
        const cdfCanvas = document.getElementById('cdfChart');
        if (pdfCanvas) pdfCanvas.getContext('2d').clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        if (cdfCanvas) cdfCanvas.getContext('2d').clearRect(0, 0, cdfCanvas.width, cdfCanvas.height);
    }
}

function renderExplanation() {
    const container = document.getElementById('explanationContent');
    container.innerHTML = currentDistribution.explanation;
}

// Global variables for data analysis
let currentData = [];

// Theme toggle functionality
function initTheme() {
    const themeToggle = document.getElementById('themeToggle');
    const currentTheme = localStorage.getItem('theme') || 'light';
    setTheme(currentTheme);

    themeToggle.addEventListener('click', () => {
        const newTheme = document.body.hasAttribute('data-theme') ? 'light' : 'dark';
        setTheme(newTheme);
    });

    function setTheme(theme) {
        if (theme === 'dark') {
            document.body.setAttribute('data-theme', 'dark');
        } else {
            document.body.removeAttribute('data-theme');
        }
        localStorage.setItem('theme', theme);

        // Update toggle icon based on theme
        const svg = themeToggle.querySelector('svg');
        if (theme === 'dark') {
            svg.innerHTML = `<path d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"/>`;
        } else {
            svg.innerHTML = `<path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/>`;
        }
    }
}

// Data input and analysis functions
function changeDataMethod() {
    const method = document.getElementById('dataMethodSelect').value;

    document.getElementById('uploadControls').style.display = method === 'upload' ? 'block' : 'none';
    document.getElementById('randomControls').style.display = method === 'random' ? 'block' : 'none';
    document.getElementById('manualControls').style.display = method === 'manual' ? 'block' : 'none';
}

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileType = file.name.split('.').pop().toLowerCase();

    if (fileType === 'csv') {
        parseCSVFile(file);
    } else if (fileType === 'xlsx' || fileType === 'xls') {
        parseExcelFile(file);
    } else {
        alert('Please upload a CSV or Excel file.');
    }
}

function parseCSVFile(file) {
    Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        complete: function(results) {
            if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file.');
                return;
            }

            const columns = Object.keys(results.data[0] || {});
            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            columns.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                columnSelect.appendChild(option);
            });

            window.parsedData = results.data.filter(row =>
                Object.values(row).some(val =>
                    typeof val === 'number' && !isNaN(val)
                )
            );

            alert(`File parsed successfully! Found ${columns.length} columns and ${window.parsedData.length} rows with numeric data.`);
        },
        error: function(error) {
            console.error('CSV parsing error:', error);
            alert('Error parsing CSV file: ' + error.message);
        }
    });
}

function parseExcelFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });

            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                defval: null
            });

            if (jsonData.length === 0) {
                alert('Excel file is empty.');
                return;
            }

            const headers = jsonData[0];
            const rows = jsonData.slice(1);

            const objectData = rows.map(row => {
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = row[i];
                });
                return obj;
            });

            window.parsedData = objectData;

            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                columnSelect.appendChild(option);
            });

            alert(`Excel file parsed successfully! Found ${headers.length} columns and ${rows.length} rows.`);
        } catch (error) {
            console.error('Excel parsing error:', error);
            alert('Error parsing Excel file: ' + error.message);
        }
    };

    reader.readAsArrayBuffer(file);
}

function processUploadedData() {
    const columnName = document.getElementById('columnSelect').value;
    if (!columnName || !window.parsedData) {
        alert('Please select a column and ensure data is loaded.');
        return;
    }

    const rawData = window.parsedData
        .map(row => row[columnName])
        .filter(val => typeof val === 'number' && !isNaN(val));

    if (rawData.length === 0) {
        alert('No valid numeric data found in the selected column.');
        return;
    }

    currentData = rawData;
    analyzeData(currentData);
}

function generateRandomData() {
    if (!currentDistribution) {
        alert('Please select a distribution first.');
        return;
    }

    const sampleSize = parseInt(document.getElementById('sampleSize').value) || 100;
    const params = getCurrentParams();

    const randomData = [];

    if (currentDistribution.name === 'Normal Distribution') {
        for (let i = 0; i < sampleSize; i++) {
            const u1 = Math.random();
            const u2 = Math.random();
            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            randomData.push(params.mu + z * Math.sqrt(params.sigma));
        }
    } else {
        // Fallback: basic random generation
        for (let i = 0; i < sampleSize; i++) {
            randomData.push(Math.random());
        }
    }

    currentData = randomData;
    analyzeData(currentData);
}

function processManualData() {
    const manualText = document.getElementById('manualDataInput').value.trim();
    if (!manualText) {
        alert('Please enter some data.');
        return;
    }

    try {
        const values = manualText.split(',')
            .map(s => s.trim())
            .map(s => parseFloat(s))
            .filter(n => !isNaN(n));

        if (values.length === 0) {
            alert('No valid numeric values found.');
            return;
        }

        currentData = values;
        analyzeData(currentData);
    } catch (error) {
        alert('Error parsing manual data: ' + error.message);
    }
}

function analyzeData(data) {
    if (data.length === 0) return;

    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
    const stdDev = Math.sqrt(variance);
    const skewness = calculateSkewness(data, mean, stdDev);
    const median = calculateMedian(data);

    displayDataAnalysisResults(data.length, mean, stdDev, skewness, median);
    renderDataChart(data);
}

function calculateSkewness(data, mean, stdDev) {
    const n = data.length;
    const skewness = data.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / n;
    return skewness;
}

function calculateMedian(data) {
    const sorted = [...data].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function displayDataAnalysisResults(count, mean, stdDev, skewness, median) {
    const kstest = performKSTest(currentData);

    document.getElementById('dataAnalysisResults').innerHTML = `
        <div class="stat-card">
            <div class="value">${count}</div>
            <div class="label">Data Points</div>
        </div>
        <div class="stat-card">
            <div class="value">${mean.toFixed(3)}</div>
            <div class="label">Mean</div>
        </div>
        <div class="stat-card">
            <div class="value">${stdDev.toFixed(3)}</div>
            <div class="label">Std Dev</div>
        </div>
        <div class="stat-card">
            <div class="value">${skewness.toFixed(3)}</div>
            <div class="label">Skewness</div>
        </div>
        <div class="stat-card">
            <div class="value">${kstest ? kstest.statistic.toFixed(3) : '--'}</div>
            <div class="label">KS Statistic</div>
        </div>
        <div class="stat-card">
            <div class="value">${kstest ? kstest.pValue.toFixed(3) : '--'}</div>
            <div class="label">KS P-Value</div>
        </div>
    `;

    displayFittingResults();
}

function performKSTest(data) {
    if (!currentDistribution || !data.length) return null;

    const sortedData = [...data].sort((a, b) => a - b);
    const params = getCurrentParams();

    let maxDifference = 0;

    sortedData.forEach((value, index) => {
        const empiricalCDF = (index + 0.5) / sortedData.length;
        let theoreticalCDF = 0.5; // fallback

        try {
            if (currentDistribution.name === 'Normal Distribution') {
                const z = (value - params.mu) / Math.sqrt(params.sigma);
                theoreticalCDF = 0.5 * (1 + math.erf(z / Math.sqrt(2)));
            } else if (currentDistribution.name === 'Uniform Distribution') {
                theoreticalCDF = (value - params.a) / (params.b - params.a);
                theoreticalCDF = Math.max(0, Math.min(1, theoreticalCDF));
            }
        } catch (e) {
            console.warn('CDF calculation error:', e);
        }

        const difference = Math.abs(empiricalCDF - theoreticalCDF);
        maxDifference = Math.max(maxDifference, difference);
    });

    const pValue = maxDifference < 0.1 ? 0.8 : maxDifference < 0.2 ? 0.5 : 0.05;

    return { statistic: maxDifference, pValue: pValue };
}

function displayFittingResults() {
    const container = document.getElementById('fittingResults');
    const params = getCurrentParams();

    let resultsHTML = '<h4>📊 Fitted Parameters:</h4><ul>';

    Object.entries(params).forEach(([param, value]) => {
        resultsHTML += `<li><strong>${param}:</strong> ${value.toFixed(4)}</li>`;
    });

    resultsHTML += '</ul>';

    container.innerHTML = resultsHTML;
}

function renderDataChart(data) {
    const ctx = document.getElementById('dataChart').getContext('2d');

    const minVal = Math.min(...data);
    const maxVal = Math.max(...data);
    const binCount = Math.min(30, Math.ceil(Math.sqrt(data.length)));

    const binWidth = (maxVal - minVal) / binCount;
    const bins = Array(binCount).fill(0);

    data.forEach(value => {
        const binIndex = Math.min(binCount - 1, Math.floor((value - minVal) / binWidth));
        bins[binIndex]++;
    });

    const binLabels = [];
    for (let i = 0; i < binCount; i++) {
        const binStart = minVal + i * binWidth;
        const binEnd = binStart + binWidth;
        binLabels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
    }

    const datasets = [{
        label: 'Histogram',
        data: bins,
        backgroundColor: 'rgba(16, 185, 129, 0.5)',
        borderColor: 'rgba(16, 185, 129, 1)',
        borderWidth: 1,
        type: 'bar'
    }];

    if (charts.data) charts.data.destroy();
    charts.data = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: binLabels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Frequency' }
                },
                x: {
                    title: { display: true, text: 'Value Range' }
                }
            },
            plugins: {
                title: { display: true, text: 'Data Histogram & Distribution Fit' }
            }
        }
    });
}

// Initialize application
document.addEventListener('DOMContentLoaded', function() {
    initTheme();
    document.getElementById('distributionSelect').value = 'normal';
    loadDistribution();
    changeDataMethod();
});
    </script>
</body>
</html>
