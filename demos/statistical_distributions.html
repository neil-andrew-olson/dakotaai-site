<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota AI - Statistical Distribution Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            color: white;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        .header h1 {
            color: white;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            margin: 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .nav-tabs button {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: #666;
        }

        .nav-tabs button.active {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .tab-panel {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .tab-panel.active {
            display: block;
        }

        .distribution-selector {
            margin-bottom: 30px;
            text-align: center;
        }

        .distribution-selector h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .distribution-selector select {
            padding: 12px;
            font-size: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            min-width: 250px;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        .params-panel, .stats-panel, .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .params-panel h3, .stats-panel h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .param-control {
            margin-bottom: 20px;
        }

        .param-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .param-control input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .chart-container {
            margin-bottom: 20px;
        }

        .chart-container h4 {
            margin-top: 0;
            color: #2c3e50 !important;
            text-align: center;
            font-weight: 600;
        }

        canvas {
            width: 100% !important;
            height: 350px !important;
            background: white !important;
        }

        .fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: white !important;
            z-index: 9999 !important;
            padding: 20px !important;
            box-sizing: border-box !important;
        }

        .fullscreen canvas {
            height: calc(100vh - 80px) !important;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .stat-card .value {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-card .label {
            font-size: 0.8rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .chart-controls select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .chart-controls button {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .chart-controls button:hover {
            background: #218838;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>


    <div class="container">
        <div class="header">
            <h1>🎲 Dakota AI Statistical Distribution Explorer</h1>
            <p>Interactive visualization of 22 probability distributions with real-time analysis and educational insights</p>
        </div>

        <div class="nav-tabs">
            <button class="active" onclick="showTab('parameters')">📊 Parameters & Data</button>
            <button onclick="showTab('visualizations')">📈 Visualizations</button>
            <button onclick="showTab('explanations')">📚 Theory</button>
        </div>

        <div class="tab-content">
            <div id="parameters" class="tab-panel active">
                <div class="distribution-selector">
                    <h3>🎯 Select Distribution</h3>
                    <select id="distributionSelect" onchange="loadDistribution()">
                        <optgroup label="Continuous Distributions" style="color: rgba(0,0,0,0.7);">
                        <option value="normal" selected>📊 Normal Distribution</option>
                            <option value="beta">🎯 Beta Distribution</option>
                            <option value="gamma">🔥 Gamma Distribution</option>
                            <option value="weibull">⚡ Weibull Distribution</option>
                            <option value="pareto">💎 Pareto Distribution</option>
                            <option value="logistic">📈 Logistic Distribution</option>
                            <option value="laplace">⬩ Laplace Distribution</option>
                            <option value="chisquared">Χ² Chi-Squared Distribution</option>
                            <option value="studentt">📚 Student-t Distribution</option>
                            <option value="fdist">📊 F-Distribution (Snedecor F)</option>
                            <option value="bivariate">🔗 Bivariate Normal Distribution</option>
                            <option value="lognormal">📉 Log-Normal Distribution</option>
                        </optgroup>
                        <optgroup label="Discrete Distributions" style="color: rgba(0,0,0,0.7);">
                            <option value="binomial">🎲 Binomial Distribution</option>
                            <option value="poisson">🎯 Poisson Distribution</option>
                            <option value="geometric">📐 Geometric Distribution</option>
                            <option value="hypergeometric">🔄 Hypergeometric Distribution</option>
                            <option value="multivariate">🔗 Multivariate Hypergeometric</option>
                            <option value="negativebinomial">📊 Negative Binomial Distribution</option>
                            <option value="multinomial">🎭 Multinomial Distribution</option>
                            <option value="uniform">📏 Discrete Uniform Distribution</option>
                        </optgroup>
                    </select>
                </div>

                <!-- Data Input Method Selection -->
                <div class="data-input-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 15px 0; color: #2c3e50;">📊 Data Input Method</h4>
                    <select id="dataMethodSelect" onchange="changeDataMethod()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; background: white;">
                        <option value="upload" selected>📁 Upload CSV/Excel File</option>
                        <option value="random">🎲 Generate Random Data</option>
                        <option value="manual">✏️ Manual Input</option>
                    </select>
                </div>

                <!-- File Upload Controls -->
                <div id="uploadControls" class="input-controls" style="margin-bottom: 15px; padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">📁 File Upload</h4>
                    <input type="file" id="fileInput" accept=".csv,.xlsx,.xls" onchange="handleFileUpload(event)" style="margin-bottom: 10px;">
                    <select id="columnSelect" style="padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; background: white; margin-right: 10px;">
                        <option value="">Select a column...</option>
                    </select>
                    <button onclick="processUploadedData()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">📊 Process Data</button>
                </div>

                <!-- Random Data Generation Controls -->
                <div id="randomControls" class="input-controls" style="margin-bottom: 15px; padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">🎲 Random Data Generation</h4>
                    <label style="margin-right: 10px;">Sample Size: <input type="number" id="sampleSize" value="100" min="10" max="10000" style="width: 80px; padding: 4px;"></label>
                    <button onclick="generateRandomData()" style="padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">🎯 Generate</button>
                </div>

                <!-- Manual Data Input Controls -->
                <div id="manualControls" class="input-controls" style="margin-bottom: 15px; padding: 15px; background: rgba(255,255,255,0.9); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">✏️ Manual Data Input</h4>
                    <textarea id="manualDataInput" placeholder="Enter comma-separated numbers (e.g., 1.2, 3.4, 5.6, 7.8)" rows="3" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;"></textarea>
                    <button onclick="processManualData()" style="padding: 6px 12px; background: #fd7e14; color: white; border: none; border-radius: 4px; cursor: pointer;">💾 Process</button>
                </div>

                <div class="content-grid">
                    <div class="params-panel">
                        <h3>⚙️ Distribution Parameters</h3>
                        <div id="paramsContainer">
                            <div class="loading">🔄 Loading distribution parameters...</div>
                        </div>
                    </div>

                    <div class="stats-panel">
                        <h3>📈 Data Analysis Results</h3>
                        <div class="stats-grid" id="dataAnalysisResults">
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Data Points</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Mean</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Sample Std Dev</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">Skewness</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS Statistic</div>
                            </div>
                            <div class="stat-card">
                                <div class="value">--</div>
                                <div class="label">KS P-Value</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="stats-panel">
                    <h3>📊 Distribution Fitting</h3>
                    <div id="fittingResults">
                        <p style="color: rgba(255,255,255,0.7); margin: 0; text-align: center;">
                            📁 Upload data to see fitted parameters and goodness-of-fit results
                        </p>
                    </div>
                </div>
            </div>

            <div id="visualizations" class="tab-panel">

                <div class="chart-controls">
                    <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                        <div>
                            <label for="chartTypeSelect" style="font-weight: 600; margin-right: 8px;">Chart Type:</label>
                            <select id="chartTypeSelect" onchange="changeChartType()">
                                <option value="pdf">📈 Probability Density (PDF)</option>
                                <option value="cdf">📊 Cumulative Distribution (CDF)</option>
                                <option value="histogram">📊 Histogram & Distribution Fit</option>
                                <option value="qqplot">📉 Q-Q Plot</option>
                                <option value="boxplot">📦 Box Plot</option>
                                <option value="scatter">🔸 Parameter Scatter Plot</option>
                                <option value="radar">🎯 Distribution Comparison</option>
                            </select>
                        </div>
                        <div>
                            <label for="styleSelect" style="font-weight: 600; margin-right: 8px;">Style:</label>
                            <select id="styleSelect" onchange="changeChartStyle()">
                                <option value="default">Default</option>
                                <option value="professional">Professional</option>
                                <option value="vibrant">Vibrant</option>
                                <option value="minimal">Minimal</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <button onclick="exportChart()" style="padding: 6px 12px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">📊 Export Chart</button>
                        <button onclick="toggleFullscreen()" style="padding: 6px 12px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">🔍 Fullscreen</button>
                        <button onclick="showInsights()" style="padding: 6px 12px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">💡 Insights</button>
                    </div>
                </div>

                <!-- Main Chart Display -->
                <div id="mainChartContainer" class="chart-container">
                    <h4 id="chartTitle">📈 Probability Density Function (PDF)</h4>
                    <canvas id="mainChart"></canvas>
                </div>

                <!-- Secondary Charts Row -->
                <div class="charts-panel" id="secondaryCharts" style="display: none;">
                </div>

                <!-- Insights Panel -->
                <div id="insightsPanel" class="chart-container" style="display: none; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(168, 85, 247, 0.1));">
                    <h4 style="color: #7c3aed;">💡 Statistical Insights</h4>
                    <div id="insightsContent"></div>
                </div>
            </div>

            <div id="explanations" class="tab-panel">
                <div class="explanation-panel">
                    <h3>📚 Statistical Distribution Theory</h3>

                    <h4>🎯 What are Probability Distributions?</h4>
                    <p>A probability distribution describes how the values of a random variable are distributed. It specifies the probabilities of different outcomes or ranges of outcomes.</p>

                    <h4>📊 Continuous vs Discrete Distributions</h4>
                    <ul>
                        <li><strong>Continuous Distributions:</strong> Random variables can take any value within a continuous range (e.g., Normal, Beta, Gamma)</li>
                        <li><strong>Discrete Distributions:</strong> Random variables take only distinct, separate values (e.g., Binomial, Poisson, Geometric)</li>
                    </ul>

                    <h4>🧪 Statistical Tests & Analysis</h4>

                    <h5>📏 Normality Tests</h5>
                    <ul>
                        <li><strong>Shapiro-Wilk Test:</strong> Most powerful normality test for small to medium samples (n < 50). Tests null hypothesis that data comes from normal distribution.</li>
                        <li><strong>Anderson-Darling Test:</strong> Enhanced version of Kolmogorov-Smirnov test, more sensitive to tails of distribution.</li>
                        <li><strong>Jarque-Bera Test:</strong> Tests normality based on skewness and kurtosis. Good for large samples.</li>
                        <li><strong>D'Agostino-Pearson Test:</strong> Omnibus test combining skewness and kurtosis assessments.</li>
                        <li><strong>Lilliefors Test:</strong> Modification of Kolmogorov-Smirnov test when parameters are estimated from data.</li>
                    </ul>

                    <h5>📊 Goodness-of-Fit Tests</h5>
                    <ul>
                        <li><strong>Chi-Square Test:</strong> Tests if observed frequencies match expected frequencies under a distribution.</li>
                        <li><strong>Kolmogorov-Smirnov Test:</strong> Tests the maximum deviation between empirical and theoretical cumulative distributions.</li>
                        <li><strong>Anderson-Darling Test:</strong> Weighted version of KS test, more sensitive to distribution tails.</li>
                    </ul>

                    <h5>🔗 Statistical Distance Measures</h5>
                    <ul>
                        <li><strong>Hellinger Distance:</strong> Symmetric measure of distribution difference, bounded [0,1].</li>
                        <li><strong>Jensen-Shannon Divergence:</strong> Symmetric version of KL divergence, always finite.</li>
                        <li><strong>Wasserstein Distance:</strong> "Earth mover's distance" - intuitive measure of distribution difference.</li>
                        <li><strong>Kullback-Leibler Divergence:</strong> Measures information loss when using one distribution to approximate another.</li>
                    </ul>

                    <h5>🧪 Statistical Tests Implemented</h5>

                    <h6>🎯 Normality Tests</h6>
                    <ul>
                        <li><strong>Shapiro-Wilk Test:</strong> W = Σ(aᵢx_(n+1-i))² / Σ((xᵢ-μ)²). Most powerful normality test for n ≤ 50. Used when sample sizes are small to medium.</li>
                        <li><strong>Anderson-Darling Test:</strong> A² = -n - Σ(2i-1)/n * [ln(F₀(xᵢ)) + ln(1-F₀(x_{(n+1-i)}))]. More sensitive to distribution tails than KS test. Good for detecting departure from normality in extreme values.</li>
                        <li><strong>Jarque-Bera Test:</strong> JB = n/6 * (S² + (K-3)²/4) where S is skewness and K is kurtosis. Tests third and fourth moments. Good for large samples. Asymptotically chi-square with 2 df.</li>
                        <li><strong>D'Agostino-Pearson Omnibus Test:</strong> Combines skewness and kurtosis tests into single omnibus normality test. Transformation-invariant. Valid for n ≥ 8.</li>
                        <li><strong>Lilliefors Test:</strong> Modified Kolmogorov-Smirnov test when parameters are unknown. Uses mean and variance estimated from sample data rather than theoretical population parameters.</li>
                    </ul>

                    <h6>📏 Goodness-of-Fit Tests</h6>
                    <ul>
                        <li><strong>Kolmogorov-Smirnov Test:</strong> D = sup|Fₙ(x) - F₀(x)| where Fₙ is empirical CDF and F₀ is theoretical CDF. Tests maximum deviation between distributions. P-values computed using correction for estimated parameters.</li>
                        <li><strong>Anderson-Darling Test (GoF):</strong> A² = -Σ(2i-1)/n * [ln(F₀(xᵢ)) + ln(1-F₀(x_{(n+1-i)}))]. Weights deviations more heavily in distribution tails.</li>
                        <li><strong>Chi-Square Goodness-of-Fit:</strong> χ² = Σ(Oᵢ - Eᵢ)²/Eᵢ where Oᵢ are observed and Eᵢ are expected frequencies. Requires binned data. Asymptotically chi-square with k-1 df.</li>
                    </ul>

                    <h6>📊 Test Result Interpretation</h6>
                    <p><strong>Hypothesis Testing Framework:</strong></p>
                    <ul>
                        <li>H₀ (Null): Data follows specified distribution</li>
                        <li>H₁ (Alternative): Data does not follow specified distribution</li>
                        <li>α (Significance Level): Usually 0.05</li>
                        <li>If p-value ≤ α: Reject H₀ (evidence of departure from specified distribution)</li>
                        <li>If p-value > α: Fail to reject H₀ (no strong evidence against specified distribution)</li>
                    </ul>

                    <p><strong>Normality Assessment Categories:</strong></p>
                    <ul>
                        <li><strong>Normal:</strong> p-value > 0.10, strongly consistent with normality</li>
                        <li><strong>Borderline:</strong> p-value between 0.01-0.10, marginal evidence against normality</li>
                        <li><strong>Non-Normal:</strong> p-value < 0.01, strong evidence data is not normal</li>
                    </ul>

                    <h4>📈 Distribution Families & Applications</h4>

                    <div class="formula" style="margin-top: 20px;">
                    <strong>CONTINUOUS DISTRIBUTIONS</strong>
                    </div>

                    <h5>🔔 Normal Distribution (Gaussian)</h5>
                    <div class="formula">f(x) = (1/(σ√(2π))) * exp(-((x-μ)²)/(2σ²))</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Measurement errors in physical experiments</li>
                        <li>Height, weight, IQ scores in populations</li>
                        <li>Stock returns under normal assumptions</li>
                        <li>Quality control tolerances</li>
                    </ul>
                    </div>

                    <h5>🎯 Beta Distribution</h5>
                    <div class="formula">f(x) = (x^(α-1) * (1-x)^(β-1)) / B(α,β)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Bayesian statistics (conjugate prior for Bernoulli)</li>
                        <li>Proportions and rates between 0-1</li>
                        <li>Project completion百分比</li>
                        <li>Acceptance probabilities in quality control</li>
                    </ul>
                    </div>

                    <h5>🔥 Gamma Distribution</h5>
                    <div class="formula">f(x) = (x^(k-1) * e^(-x/θ)) / (θ^k * Γ(k))</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Waiting times between Poisson events</li>
                        <li>Reliability engineering (component lifetimes)</li>
                        <li>Insurance claims amounts</li>
                        <li>Rainfall amounts, tornado intensities</li>
                    </ul>
                    </div>

                    <h5>⚡ Weibull Distribution</h5>
                    <div class="formula">f(x) = (k/λ) * (x/λ)^(k-1) * exp(-(x/λ)^k)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Failure analysis and reliability engineering</li>
                        <li>Wind speed modeling</li>
                        <li>Material fatigue life analysis</li>
                        <li>Product lifetime testing</li>
                    </ul>
                    </div>

                    <h5>💎 Pareto Distribution (Power Law)</h5>
                    <div class="formula">f(x) = α x₀^α / x^(α+1)  for x ≥ x₀</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Income inequality analysis (80/20 rule)</li>
                        <li>City population sizes</li>
                        <li>File size distributions in networks</li>
                        <li>Insurance claims with high deductibles</li>
                    </ul>
                    </div>

                    <h5>📉 Log-Normal Distribution</h5>
                    <div class="formula">f(x) = (1/(xσ√(2π))) * exp[-(ln(x)-μ)²/(2σ²)]</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Stock prices in Black-Scholes model</li>
                        <li>Particle sizes in materials science</li>
                        <li>Concentrations in environmental studies</li>
                        <li>Survival times with multiplicative effects</li>
                    </ul>
                    </div>

                    <h5>⚖️ Student-t Distribution</h5>
                    <div class="formula">f(x) = Γ((ν+1)/2) / (√(νπ) * Γ(ν/2)) * (1 + x²/ν)^(-(ν+1)/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Statistical inference with small samples (t-tests)</li>
                        <li>Confidence intervals when population variance unknown</li>
                        <li>Regression analysis residuals</li>
                        <li>Robust statistical methods</li>
                    </ul>
                    </div>

                    <h5>⏹️ Uniform Distribution (Continuous)</h5>
                    <div class="formula">f(x) = 1/(b-a)  for a ≤ x ≤ b</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Random number generation</li>
                        <li>Round-off errors in measurements</li>
                        <li>Physical measurements with limited precision</li>
                        <li>Bayesian prior for lack of information</li>
                    </ul>
                    </div>

                    <h5>📈 Logistic Distribution</h5>
                    <div class="formula">f(x) = (1/s) * exp(-(x-μ)/s) / (1 + exp(-(x-μ)/s))²</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Growth models in biology and economics</li>
                        <li>Neural network activation functions</li>
                        <li>Probit/logit regression models</li>
                        <li>Demographic population modeling</li>
                    </ul>
                    </div>

                    <h5>⬩ Laplace Distribution (Double Exponential)</h5>
                    <div class="formula">f(x) = (1/(2b)) * exp(-|x-μ|/b)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Modeling absolute deviations/errors</li>
                        <li>Robust statistics alternatives to normal</li>
                        <li>Signal processing with heavy tails</li>
                        <li>Financial modeling of extreme events</li>
                    </ul>
                    </div>

                    <h5>✅ Chi-Squared Distribution</h5>
                    <div class="formula">f(x) = (1/(2^(k/2) * Γ(k/2))) * x^(k/2 - 1) * exp(-x/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Chi-squared tests for independence</li>
                        <li>Goodness-of-fit tests</li>
                        <li>Variance estimation and testing</li>
                        <li>Quality control and process capability</li>
                    </ul>
                    </div>

                    <h5>📊 F-Distribution (Snedecor F)</h5>
                    <div class="formula">f(x) = Γ((d₁+d₂)/2) / Γ(d₁/2)Γ(d₂/2) * (d₁/d₂)^(d₁/2) * x^(d₁/2-1) * (1 + (d₁/d₂)x)^(-(d₁+d₂)/2)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>ANOVA (Analysis of Variance)</li>
                        <li>F-tests for equal variances</li>
                        <li>Regression analysis significance tests</li>
                        <li>Generalized linear models</li>
                    </ul>
                    </div>

                    <h5>🔗 Bivariate Normal Distribution</h5>
                    <div class="formula">f(x,y) = (1/(2πσ₁σ₂√(1-ρ²))) * exp[-1/(2(1-ρ²))] * [(x-μ₁)²/σ₁² - 2ρ(x-μ₁)(y-μ₂)/(σ₁σ₂) + (y-μ₂)²/σ₂²]</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Multivariate analysis of correlated variables</li>
                        <li>Asset returns in portfolio optimization</li>
                        <li>Biological measurements (height-weight correlations)</li>
                        <li>Economic indicators analysis</li>
                    </ul>
                    </div>

                    <div class="formula" style="margin-top: 30px;">
                    <strong>DISCRETE DISTRIBUTIONS</strong>
                    </div>

                    <h5>🎲 Binomial Distribution</h5>
                    <div class="formula">P(X = k) = C(n,k) × p^k × (1-p)^(n-k)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Success/failure experiments with fixed trials</li>
                        <li>Quality control (defective items in sample)</li>
                        <li>Election outcomes in voting polls</li>
                        <li>Clinical trials response counts</li>
                    </ul>
                    </div>

                    <h5>🎯 Poisson Distribution</h5>
                    <div class="formula">P(X = k) = e^(-λ) * λ^k / k!</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Events occurring in fixed time/space intervals</li>
                        <li>Customer arrivals at service centers</li>
                        <li>Radioactive decay events counting</li>
                        <li>Traffic accidents at intersections</li>
                    </ul>
                    </div>

                    <h5>📐 Geometric Distribution</h5>
                    <div class="formula">P(X = k) = (1-p)^(k-1) * p</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Waiting time until first success</li>
                        <li>Reliability (trials until first failure)</li>
                        <li>Quality control (items until first defect)</li>
                        <li>Sales calls until first sale</li>
                    </ul>
                    </div>

                    <h5>🔄 Hypergeometric Distribution</h5>
                    <div class="formula">P(X = k) = [C(K,k) × C(N-K,n-k)] / C(N,n)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Sampling without replacement from finite populations</li>
                        <li>Quality control lot sampling</li>
                        <li>Election auditing procedures</li>
                        <li>Card game probability calculations</li>
                    </ul>
                    </div>

                    <h5>📊 Negative Binomial Distribution</h5>
                    <div class="formula">P(X = k) = C(k-1,r-1) × p^r × (1-p)^(k-r)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Number of trials needed for r successes</li>
                        <li>Quality control (trials until r defects)</li>
                        <li>Sales (attempts until r sales made)</li>
                        <li>Epidemiology (contacts until r infections)</li>
                    </ul>
                    </div>

                    <h5>🔗 Multivariate Hypergeometric Distribution</h5>
                    <div class="formula">P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [∏ C(Kᵢ,kᵢ)] / C(N,n)</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Elections with multiple candidate categories</li>
                        <li>Contingency table analysis</li>
                        <li>Multivariate sampling from categorized populations</li>
                        <li>Genetics and population studies</li>
                    </ul>
                    </div>

                    <h5>🎭 Multinomial Distribution</h5>
                    <div class="formula">P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [n! / (k₁!k₂!...kₘ!)] × p₁^k₁ × p₂^k₂ × ... × pₘ^kₘ</div>
                    <div class="applications">
                    <strong>Applications:</strong>
                    <ul>
                        <li>Election results across multiple parties</li>
                        <li>Consumer choice modeling</li>
                        <li>Marketing response categorization</li>
                        <li>Genetic inheritance patterns</li>
                    </ul>
                    </div>

                    <h4>📋 Key Statistical Concepts</h4>
                    <ul>
                        <li><strong>Parameters vs Statistics:</strong> Parameters describe population distributions, statistics describe samples</li>
                        <li><strong>Maximum Likelihood Estimation (MLE):</strong> Method for estimating distribution parameters from data</li>
                        <li><strong>Goodness-of-Fit Tests:</strong> Kolmogorov-Smirnov test assesses how well data fits a distribution</li>
                        <li><strong>Central Limit Theorem:</strong> Sample means approach normal distribution regardless of parent distribution</li>
                        <li><strong>Law of Large Numbers:</strong> Sample statistics converge to population parameters with increasing sample size</li>
                    </ul>

                    <h4>🔍 Choosing the Right Distribution</h4>
                    <ul>
                        <li><strong>Data Type:</strong> Continuous/interval data → continuous distributions, discrete/count data → discrete distributions</li>
                        <li><strong>Data Range:</strong> Bounded (0-1) data → Beta, positive only → Gamma/Exponential, unlimited → Normal</li>
                        <li><strong>Shape Characteristics:</strong> Symmetry (Normal), right-skewness (Gamma, Weibull), heavy tails (t-distribution)</li>
                        <li><strong>Subject Matter Knowledge:</strong> Domain expertise often guides choice (e.g., Pareto for wealth distributions)</li>
                        <li><strong>Statistical Tests:</strong> Use goodness-of-fit tests to validate distribution assumptions</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
// Error handling and performance utilities
const ErrorHandler = {
    log: (error, context = '') => {
        console.error(`[StatDistribution] ${context}:`, error);
    },
    
    showUserError: (message, element = null) => {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `
            <div style="background: #fee; border: 1px solid #fcc; padding: 10px; border-radius: 4px; margin: 10px 0; color: #c33;">
                <strong>⚠️ Error:</strong> ${message}
            </div>
        `;
        
        const container = element || document.getElementById('dataAnalysisResults') || document.body;
        container.appendChild(errorDiv);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.parentNode.removeChild(errorDiv);
            }
        }, 5000);
    },
    
    clearErrors: () => {
        document.querySelectorAll('.error-message').forEach(el => el.remove());
    }
};

const LoadingManager = {
    show: (element, message = 'Loading...') => {
        const loader = document.createElement('div');
        loader.className = 'loading-overlay';
        loader.innerHTML = `
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                        background: rgba(255,255,255,0.9); padding: 20px; border-radius: 8px; 
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15); text-align: center;">
                <div style="width: 24px; height: 24px; border: 3px solid #3498db; border-top: 3px solid transparent; 
                           border-radius: 50%; margin: 0 auto 10px; animation: spin 1s linear infinite;"></div>
                <div>${message}</div>
            </div>
            <style>
                @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            </style>
        `;
        loader.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; background: rgba(255,255,255,0.7);';
        
        if (element) {
            element.style.position = 'relative';
            element.appendChild(loader);
        }
        
        return loader;
    },
    
    hide: (loader) => {
        if (loader && loader.parentNode) {
            loader.parentNode.removeChild(loader);
        }
    }
};

// Enhanced chart management
const ChartManager = {
    charts: new Map(),
    
    create: (canvasId, config) => {
        try {
            // Destroy existing chart if it exists
            ChartManager.destroy(canvasId);
            
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                throw new Error(`Canvas element with id '${canvasId}' not found`);
            }
            
            const chart = new Chart(canvas, config);
            ChartManager.charts.set(canvasId, chart);
            return chart;
        } catch (error) {
            ErrorHandler.log(error, `Creating chart ${canvasId}`);
            ErrorHandler.showUserError(`Failed to create chart: ${error.message}`);
            return null;
        }
    },
    
    destroy: (canvasId) => {
        const chart = ChartManager.charts.get(canvasId);
        if (chart && typeof chart.destroy === 'function') {
            try {
                chart.destroy();
            } catch (error) {
                ErrorHandler.log(error, `Destroying chart ${canvasId}`);
            }
        }
        ChartManager.charts.delete(canvasId);
    },
    
    destroyAll: () => {
        ChartManager.charts.forEach((chart, id) => {
            ChartManager.destroy(id);
        });
    }
};

// Mobile detection and responsive utilities
const ResponsiveUtils = {
    isMobile: () => window.innerWidth <= 768,
    isTablet: () => window.innerWidth <= 1024 && window.innerWidth > 768,
    
    optimizeForMobile: () => {
        if (ResponsiveUtils.isMobile()) {
            // Reduce chart height on mobile
            document.querySelectorAll('canvas').forEach(canvas => {
                canvas.style.height = '250px';
            });
            
            // Simplify UI for mobile
            const chartControls = document.querySelector('.chart-controls');
            if (chartControls) {
                chartControls.style.flexDirection = 'column';
                chartControls.style.gap = '10px';
            }
        }
    }
};

// Data export utilities
const DataExporter = {
    exportCSV: (data, filename = 'statistical_data.csv') => {
        try {
            let csvContent = '';
            
            if (Array.isArray(data[0])) {
                // 2D array
                csvContent = data.map(row => row.join(',')).join('\n');
            } else {
                // 1D array
                csvContent = 'Value\n' + data.join('\n');
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
        } catch (error) {
            ErrorHandler.log(error, 'Exporting CSV');
            ErrorHandler.showUserError('Failed to export data as CSV');
        }
    },
    
    exportChartImage: (canvasId, filename) => {
        try {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                throw new Error(`Canvas ${canvasId} not found`);
            }
            
            const link = document.createElement('a');
            link.download = filename || `${canvasId}-${new Date().toISOString().slice(0,10)}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            ErrorHandler.log(error, 'Exporting chart image');
            ErrorHandler.showUserError('Failed to export chart image');
        }
    }
};

// Distribution definitions with parameters and explanations
window.distributions = {
            normal: {
                name: "Normal Distribution",
                params: [
                    { name: "μ (mean)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "σ (standard deviation)", id: "sigma", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Normal distribution, discovered by Carl Friedrich Gauss, is the cornerstone of statistical inference and the Central Limit Theorem. It describes phenomena where many small, independent random effects combine additively.</p>

                    <div class="formula">
                    f(x; μ, σ) = (1/(σ√(2π))) * exp(-((x-μ)²)/(2σ²))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (mean)</strong>: Location parameter - determines the center/peak of the distribution</li>
                        <li><strong>σ (standard deviation)</strong>: Scale parameter - controls the spread/variance (σ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Measurement Science</strong>: Heights, weights, IQ scores, blood pressure</li>
                        <li><strong>Quality Control</strong>: Manufacturing tolerances, product specifications</li>
                        <li><strong>Finance</strong>: Stock returns (under log-normal assumptions), option pricing</li>
                        <li><strong>Natural Phenomena</strong>: Light intensity, particle velocities, astronomical measurements</li>
                        <li><strong>Psychometrics</strong>: Test scores, reaction times, cognitive abilities</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Symmetric with mean = median = mode = μ</li>
                        <li>68-95-99.7 rule: 68% within 1σ, 95% within 1.96σ, 99.7% within 3σ</li>
                        <li>Inflection points at μ ± σ</li>
                        <li>Maximum entropy distribution for given mean and variance</li>
                        <li>Stable under addition (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Historical Context:</strong> First derived by Abraham de Moivre in 1733 for binomial approximations. Gauss proved its universal importance in the theory of errors.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    // Using approximation for normal CDF
                    const mu = params.mu, sigma = params.sigma;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: mu,
                        variance: sigma * sigma,
                        skewness: 0,
                        kurtosis: 0,
                        median: mu,
                        mode: mu
                    };
                }
            },

            binomial: {
                name: "Binomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 100, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.5, min: 0, max: 1, step: 0.01 }
                ],
                explanation: `
                    <p>The Binomial distribution was developed by Jacob Bernoulli and is one of the earliest distributions in probability theory. It models scenarios where we conduct a fixed number of independent trials, each having exactly two possible outcomes (success/failure).</p>

                    <div class="formula">
                    P(X = k) = C(n,k) × p^k × (1-p)^(n-k)
                    </div>

                    <div class="formula" style="margin-top: 10px;">
                    C(n,k) = n! / (k! × (n-k)!)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n (number of trials)</strong>: Fixed sample size (must be a positive integer)</li>
                        <li><strong>p (success probability)</strong>: Probability of success on any single trial (0 ≤ p ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications & Examples:</strong></p>
                    <ul>
                        <li><strong>Clinical Trials</strong>: Number of patients who respond to a treatment</li>
                        <li><strong>Quality Assurance</strong>: Proportion of defective products in a batch</li>
                        <li><strong>Elections</strong>: Number of votes for a candidate in exit polls</li>
                        <li><strong>A/B Testing</strong>: Conversion rates in website optimization</li>
                        <li><strong>Risk Assessment</strong>: Number of claims in an insurance portfolio</li>
                        <li><strong>Biology</strong>: Number of males in a litter of fixed size</li>
                    </ul>
                    </div>

                    <p><strong>Theoretical Properties:</strong></p>
                    <ul>
                        <li>Mean = np, Variance = np(1-p)</li>
                        <li>Symmetric when p = 0.5, right-skewed when p < 0.5, left-skewed when p > 0.5</li>
                        <li>Maximum value is n (all successes), minimum is 0 (no successes)</li>
                        <li>Approaches Poisson distribution as n→∞ and p→0 (with λ = np fixed)</li>
                        <li>Approaches Normal distribution as n→∞ (Central Limit Theorem)</li>
                    </ul>

                    <p><strong>Theoretical Foundations:</strong> Based on Bernoulli trials with independence assumption. Each trial must be identical and the outcome probabilities must remain constant across trials.</p>

                    <p><strong>Assumptions:</strong> Fixed number of trials, independence between trials, constant success probability, only two possible outcomes per trial.</p>
                `,
                pmf: (k, params) => {
                    const n = params.n, p = params.p;
                    if (k < 0 || k > n) return 0;
                    return math.combinations(n, k) * Math.pow(p, k) * Math.pow(1-p, n-k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const n = params.n, p = params.p;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p),
                        skewness: (1 - 2*p) / Math.sqrt(n * p * (1-p)),
                        kurtosis: (1 - 6*p*(1-p)) / (n * p * (1-p)),
                        median: Math.round(n * p),
                        mode: Math.round((n + 1) * p)
                    };
                }
            },

            poisson: {
                name: "Poisson Distribution",
                params: [
                    { name: "λ (rate parameter)", id: "lambda", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Poisson distribution models the number of events occurring in a fixed interval of time or space.</p>

                    <div class="formula">
                    P(X = k) = e^(-λ) * λ^k / k!
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>λ (lambda)</strong>: Average rate of events (λ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of customer arrivals per hour</li>
                        <li>Number of defects in a product</li>
                        <li>Number of phone calls received</li>
                        <li>Number of accidents at an intersection</li>
                        <li>Radioactive decay events</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete distribution. Mean = Variance = λ. Right-skewed for small λ, approaches normal as λ increases.</p>
                `,
                pmf: (k, params) => {
                    const lambda = params.lambda;
                    if (k < 0) return 0;
                    return Math.exp(-lambda) * Math.pow(lambda, k) / math.factorial(k);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const lambda = params.lambda;
                    return {
                        mean: lambda,
                        variance: lambda,
                        skewness: 1/Math.sqrt(lambda),
                        kurtosis: 1/lambda,
                        median: Math.round(lambda + 1/3 - 0.02/lambda),
                        mode: Math.floor(lambda)
                    };
                }
            },

            beta: {
                name: "Beta Distribution",
                params: [
                    { name: "α (shape parameter)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "β (shape parameter)", id: "beta", default: 2, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Beta distribution models random variables whose values are constrained to a finite interval [0,1].</p>

                    <div class="formula">
                    f(x) = (x^(α-1) * (1-x)^(β-1)) / B(α,β)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>α (alpha)</strong>: Shape parameter (α > 0)</li>
                        <li><strong>β (beta)</strong>: Shape parameter (β > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Proportions and rates between 0 and 1</li>
                        <li>Bayesian statistics (conjugate prior for Bernoulli)</li>
                        <li>Time allocation between activities</li>
                        <li>Quality control (percentage defective)</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shapes from uniform to U-shaped. Mean = α/(α+β), Variance = αβ/((α+β)²(α+β+1)).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0 || x > 1) return 0;
                    const alpha = params.alpha, beta = params.beta;
                    return Math.pow(x, alpha-1) * Math.pow(1-x, beta-1) / math.beta(alpha, beta);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    if (x >= 1) return 1;
                    // Simple approximation since betinc function may not be available
                    const alpha = params.alpha, beta = params.beta;
                    // Using regularized incomplete beta function approximation
                    try {
                        if (typeof math.betainc === 'function') {
                            return math.betainc(x, alpha, beta);
                        }
                    } catch (e) {
                        // Fallback approximation
                        return x; // Very simple fallback
                    }
                    return x; // Simple fallback
                },
                stats: (params) => {
                    const alpha = params.alpha, beta = params.beta;
                    const total = alpha + beta;
                    return {
                        mean: alpha / total,
                        variance: (alpha * beta) / (total * total * (total + 1)),
                        skewness: (2 * (beta - alpha) * Math.sqrt(total + 1)) / ((total + 2) * Math.sqrt(alpha * beta)),
                        kurtosis: (6 * (alpha - beta) * (alpha - beta) * (total + 1) - alpha * beta * (total + 2)) / (alpha * beta * (total + 2) * (total + 3)),
                        median: (alpha - 1/3) / (total - 2/3), // approximation
                        mode: (alpha - 1) / (total - 2)
                    };
                }
            },

            gamma: {
                name: "Gamma Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "θ (scale)", id: "theta", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Gamma distribution generalizes the exponential distribution and is used for positive continuous variables.</p>

                    <div class="formula">
                    f(x) = (x^(k-1) * e^(-x/θ)) / (θ^k * Γ(k))
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>θ (scale)</strong>: Scale parameter (θ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Waiting times between Poisson events</li>
                        <li>Life testing and reliability engineering</li>
                        <li>Size of insurance claims</li>
                        <li>Queueing theory</li>
                        <li>Bayesian statistics (conjugate prior)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal as k increases. Mean = kθ, Variance = kθ².</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, theta = params.theta;
                    return Math.pow(x, k-1) * Math.exp(-x/theta) / (Math.pow(theta, k) * math.gamma(k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, theta = params.theta;
                    return math.gammainc(k, x/theta);
                },
                stats: (params) => {
                    const k = params.k, theta = params.theta;
                    return {
                        mean: k * theta,
                        variance: k * theta * theta,
                        skewness: 2 / Math.sqrt(k),
                        kurtosis: 6 / k,
                        median: theta * (k - 1/3), // approximation
                        mode: theta * (k - 1)
                    };
                }
            },

            geometric: {
                name: "Geometric Distribution",
                params: [
                    { name: "p (success probability)", id: "p", default: 0.3, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Geometric distribution models the number of trials needed to get the first success in Bernoulli trials.</p>

                    <div class="formula">
                    P(X = k) = (1-p)^(k-1) * p
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>p</strong>: Probability of success in each trial (0 < p ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Number of attempts needed to succeed</li>
                        <li>Reliability engineering (time to first failure)</li>
                        <li>Customer service (calls until first success)</li>
                        <li>Quality control (items inspected until first defect)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Memoryless property (like exponential distribution). Mean = 1/p, Variance = (1-p)/p².</p>
                `,
                pmf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return Math.pow(1-p, k-1) * p;
                },
                cdf: (k, params) => {
                    const p = params.p;
                    if (k < 1) return 0;
                    return 1 - Math.pow(1-p, k);
                },
                stats: (params) => {
                    const p = params.p;
                    return {
                        mean: 1/p,
                        variance: (1-p)/(p*p),
                        skewness: (2-p)/Math.sqrt(1-p),
                        kurtosis: (p*p - 6*p + 6)/(1-p),
                        median: Math.ceil(-Math.log(2)/Math.log(1-p)),
                        mode: 1
                    };
                }
            },

            hypergeometric: {
                name: "Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 2, max: 100, step: 1 },
                    { name: "K (success states)", id: "K", default: 7, min: 0, max: 20, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The Hypergeometric distribution models sampling without replacement from a finite population.</p>

                    <div class="formula">
                    P(X = k) = [C(K,k) × C(N-K,n-k)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size (N ≥ 1)</li>
                        <li><strong>K</strong>: Number of successes in population (0 ≤ K ≤ N)</li>
                        <li><strong>n</strong>: Sample size without replacement (0 < n ≤ N)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (sampling from production lots)</li>
                        <li>Election auditing (sample verification)</li>
                        <li>Card games and lottery draws</li>
                        <li>Biological sampling (capture-recapture)</li>
                        <li>Mining and mineral exploration</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Discrete, mean = nK/N, variance = nK/N(1-K/N)(N-n)/(N-1). Approaches binomial as N→∞.</p>
                `,
                pmf: (k, params) => {
                    const N = params.N, K = params.K, n = params.n;
                    if (k < Math.max(0, n - (N - K)) || k > Math.min(n, K)) return 0;
                    const comb1 = math.combinations(K, k);
                    const comb2 = math.combinations(N - K, n - k);
                    const comb3 = math.combinations(N, n);
                    return (comb1 * comb2) / comb3;
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = 0; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const N = params.N, K = params.K, n = params.n;
                    const p = K / N;
                    return {
                        mean: n * p,
                        variance: n * p * (1 - p) * (N - n) / (N - 1),
                        skewness: ((N - 2*K) * Math.sqrt(N - 1) * Math.sqrt(N - n)) / (Math.sqrt(n * K * (N - K) * (N - n)) * Math.sqrt(N - 2)),
                        kurtosis: 'Complex calculation needed',
                        median: Math.round(n * K / N),
                        mode: Math.round((n + 1) * (K + 1) / (N + 2))
                    };
                }
            },

            multivariate: {
                name: "Multivariate Hypergeometric Distribution",
                params: [
                    { name: "N (population size)", id: "N", default: 20, min: 5, max: 100, step: 1 },
                    { name: "n (sample size)", id: "n", default: 6, min: 1, max: 20, step: 1 }
                ],
                explanation: `
                    <p>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution used when there are multiple categories.</p>

                    <div class="formula">
                    P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [∏ C(Kᵢ,kᵢ)] / C(N,n)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>N</strong>: Total population size</li>
                        <li><strong>n</strong>: Sample size</li>
                        <li><strong>Kⱼ</strong>: Size of each category in population</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election sampling with multiple parties</li>
                        <li>Contingency table analysis</li>
                        <li>Multiple classification sampling</li>
                        <li>Genetics and population studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multidimensional generalization of hypergeometric. Used in multivariate statistics and experimental design.</p>
                `,
                // Note: This is a simplification - true multivariate hypergeometric would need category sizes
                pmf: (k, params) => {
                    // This is a placeholder - multivariate hypergeometric is complex
                    return 0.1; // Placeholder value
                },
                cdf: (k, params) => {
                    // Approximation for demonstration
                    return 0.5;
                },
                stats: (params) => {
                    const N = params.N, n = params.n;
                    return {
                        mean: 'Multi-dimensional',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Multi-dimensional'
                    };
                }
            },

            negativebinomial: {
                name: "Negative Binomial Distribution",
                params: [
                    { name: "r (successes)", id: "r", default: 5, min: 1, max: 20, step: 1 },
                    { name: "p (success probability)", id: "p", default: 0.4, min: 0.01, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The Negative Binomial distribution models the number of trials needed to achieve a specified number of successes.</p>

                    <div class="formula">
                    P(X = k) = C(k-1,r-1) × p^r × (1-p)^(k-r)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>r</strong>: Number of successes required (r ≥ 1)</li>
                        <li><strong>p</strong>: Probability of success on each trial (0 < p < 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Quality control (trials until r defects found)</li>
                        <li>Sales (attempts until r sales made)</li>
                        <li>Sports (games until r wins)</li>
                        <li>Reliability (failures until r successful tests)</li>
                        <li>Epidemiology (contacts until r infections)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Overdispersion compared to Poisson. Mean = r/p, Variance = r(1-p)/p². Special case of Poisson when r=1 (geometric).</p>
                `,
                pmf: (k, params) => {
                    const r = params.r, p = params.p;
                    if (k < r) return 0;
                    return math.combinations(k-1, r-1) * Math.pow(p, r) * Math.pow(1-p, k-r);
                },
                cdf: (k, params) => {
                    let sum = 0;
                    for (let i = params.r; i <= k; i++) {
                        sum += this.pmf(i, params);
                    }
                    return sum;
                },
                stats: (params) => {
                    const r = params.r, p = params.p;
                    return {
                        mean: r / p,
                        variance: r * (1 - p) / (p * p),
                        skewness: (2 - p) / Math.sqrt(r * (1 - p)),
                        kurtosis: (p * p - 6 * p + 6) / (r * (1 - p)),
                        median: 'Approximation needed',
                        mode: Math.floor((r - 1) * (1 - p) / p) + r
                    };
                }
            },

            multinomial: {
                name: "Multinomial Distribution",
                params: [
                    { name: "n (trials)", id: "n", default: 10, min: 1, max: 50, step: 1 }
                ],
                explanation: `
                    <p>The Multinomial distribution is a generalization of the binomial distribution for experiments with more than two possible outcomes.</p>

                    <div class="formula">
                    P(X₁ = k₁, X₂ = k₂, ..., Xₘ = kₘ) = [n! / (k₁!k₂!...kₘ!)] × p₁^k₁ × p₂^k₂ × ... × pₘ^kₘ
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>n</strong>: Number of independent trials</li>
                        <li><strong>pⱼ</strong>: Probability of each outcome category (∑pⱼ = 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Election results across multiple parties</li>
                        <li>Marketing response categories</li>
                        <li>Genetic inheritance patterns</li>
                        <li>Consumer preference studies</li>
                        <li>Disease classification studies</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Multivariate generalization of binomial. Mean vector = n*p, covariance matrix = n*diag(p) - n*p*p^T.</p>
                `,
                // Note: This is highly simplified - multinomial distribution is complex for visualization
                pmf: (k, params) => {
                    // Placeholder - real multinomial is multivariate
                    return 0.1;
                },
                cdf: (k, params) => {
                    return 0.5;
                },
                stats: (params) => {
                    const n = params.n;
                    return {
                        mean: 'Vector-valued',
                        variance: 'Matrix-valued',
                        skewness: 'Complex',
                        kurtosis: 'Complex',
                        median: 'Multi-dimensional',
                        mode: 'Complex'
                    };
                }
            },

            uniform: {
                name: "Continuous Uniform Distribution",
                params: [
                    { name: "a (min)", id: "a", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (max)", id: "b", default: 1, min: -10, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Continuous Uniform distribution has constant probability density over a finite interval.</p>

                    <div class="formula">
                    f(x) = 1/(b-a)  for a ≤ x ≤ b
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>a</strong>: Minimum value</li>
                        <li><strong>b</strong>: Maximum value (b > a)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Random number generation</li>
                        <li>Round-off errors</li>
                        <li>Physical measurements with limited precision</li>
                        <li>Simulation modeling</li>
                        <li>Bayesian prior (lack of information)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Rectangular shape. Mean = (a+b)/2, Variance = (b-a)²/12. No mode (every value equally likely).</p>
                `,
                pdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x < a || x > b || a >= b) return 0;
                    return 1/(b-a);
                },
                cdf: (x, params) => {
                    const a = params.a, b = params.b;
                    if (x <= a) return 0;
                    if (x >= b) return 1;
                    return (x - a)/(b - a);
                },
                stats: (params) => {
                    const a = params.a, b = params.b;
                    const range = b - a;
                    return {
                        mean: (a + b) / 2,
                        variance: range * range / 12,
                        skewness: 0,
                        kurtosis: -6/5,
                        median: (a + b) / 2,
                        mode: 'No unique mode (uniform)'
                    };
                }
            },

            studentt: {
                name: "Student-t Distribution",
                params: [
                    { name: "ν (degrees of freedom)", id: "df", default: 5, min: 0.5, max: 30, step: 0.5 }
                ],
                explanation: `
                    <p>The Student-t distribution arises from estimating the mean of a normally distributed population with unknown variance.</p>

                    <div class="formula">
                    f(x) = Γ((ν+1)/2) / (√(νπ) * Γ(ν/2)) * (1 + x²/ν)^(-(ν+1)/2)
                    </div>

                    <p><strong>Parameters:</strong> ν (degrees of freedom) - Shape parameter determining tail heaviness</p>

                    <div class="applications">
                    <p><strong>Applications:</strong> Statistical inference, confidence intervals, regression analysis</p>
                    </div>

                    <p><strong>Properties:</strong> Symmetric bell-shaped curve with heavier tails than normal. Approaches normal as ν→∞.</p>
                `,
                pdf: (x, params) => {
                    try {
                        const df = params.df;
                        if (df <= 0) return 0;

                        // Simplified calculation to avoid gamma function issues
                        const factor = Math.pow(1 + x*x/df, -(df+1)/2);
                        // Approximate gamma ratio for common degrees of freedom
                        let gamma_ratio = 1;
                        if (Math.abs(df - 5) < 0.1) gamma_ratio = 1.75; // Approximation for df=5
                        else if (Math.abs(df - 10) < 0.1) gamma_ratio = 1.22; // Approximation for df=10
                        else gamma_ratio = Math.sqrt(df/Math.PI); // Rough approximation

                        return (gamma_ratio / Math.sqrt(df * Math.PI)) * factor;
                    } catch (e) {
                        return 0;
                    }
                },
                cdf: (x, params) => {
                    try {
                        const df = params.df;
                        if (df <= 0) return 0.5;

                        // Simple approximation using normal approximation for larger df
                        if (df > 30) {
                            const z = x;
                            return 0.5 * (1 + Math.erf(z/Math.sqrt(2)));
                        }

                        // For small df, use tanh approximation
                        const z = x / Math.sqrt(df);
                        return 0.5 + 0.5 * Math.tanh(z * Math.sqrt(df/2));
                    } catch (e) {
                        return 0.5;
                    }
                },
                stats: (params) => {
                    const df = params.df;
                    return {
                        mean: df > 1 ? 0 : 'Undefined',
                        variance: df > 2 ? df/(df-2) : 'Undefined',
                        skewness: 0,
                        kurtosis: df > 4 ? 6/(df-4) : 'Undefined',
                        median: 0,
                        mode: 0
                    };
                }
            },

            weibull: {
                name: "Weibull Distribution",
                params: [
                    { name: "k (shape)", id: "k", default: 1.5, min: 0.1, max: 10, step: 0.1 },
                    { name: "λ (scale)", id: "lambda", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Weibull distribution is widely used in reliability engineering and survival analysis.</p>

                    <div class="formula">
                    f(x) = (k/λ) * (x/λ)^(k-1) * exp(-(x/λ)^k)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (shape)</strong>: Shape parameter (k > 0)</li>
                        <li><strong>λ (scale)</strong>: Scale parameter (λ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Reliability engineering (failure times)</li>
                        <li>Survival analysis</li>
                        <li>Wind speed modeling</li>
                        <li>Material fatigue life</li>
                        <li>Product lifetime analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Flexible shape - exponential when k=1, right-skewed for k<1, approaches normal for large k. Mean = λΓ(1+1/k), Variance = λ²[Γ(1+2/k) - Γ²(1+1/k)].</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return (k/lambda) * Math.pow(x/lambda, k-1) * Math.exp(-Math.pow(x/lambda, k));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k, lambda = params.lambda;
                    return 1 - Math.exp(-Math.pow(x/lambda, k));
                },
                stats: (params) => {
                    const k = params.k, lambda = params.lambda;
                    return {
                        mean: lambda * math.gamma(1 + 1/k),
                        variance: lambda*lambda * (math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2)),
                        skewness: (math.gamma(1 + 3/k) - 3*math.gamma(1 + 1/k)*math.gamma(1 + 2/k) + 2*Math.pow(math.gamma(1 + 1/k), 3)) / Math.pow(math.gamma(1 + 2/k) - Math.pow(math.gamma(1 + 1/k), 2), 1.5),
                        kurtosis: 'Complex calculation needed',
                        median: lambda * Math.pow(Math.log(2), 1/k),
                        mode: lambda * Math.pow((k-1)/k, 1/k)
                    };
                }
            },

            pareto: {
                name: "Pareto Distribution",
                params: [
                    { name: "α (shape)", id: "alpha", default: 2, min: 0.1, max: 10, step: 0.1 },
                    { name: "x₀ (scale)", id: "x0", default: 1, min: 0.1, max: 10, step: 0.1 }
                ],
                explanation: `
                    <p>The Pareto distribution models phenomena where a small number of events account for a large proportion of outcomes.</p>

                    <div class="formula">
                    f(x) = α x₀^α / x^(α+1)  for x ≥ x₀
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>α (shape)</strong>: Shape parameter (α > 0)</li>
                        <li><strong>x₀ (scale)</strong>: Minimum value (x₀ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Income distribution (80/20 rule)</li>
                        <li>City population sizes</li>
                        <li>File size distribution</li>
                        <li>Insurance claims</li>
                        <li>Ecosystem species abundance</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Heavy tail, used in power-law phenomena. Mean = αx₀/(α-1) for α>1. Variance undefined for α≤2.</p>
                `,
                pdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x < x0) return 0;
                    return alpha * Math.pow(x0/alpha, alpha) / Math.pow(x, alpha + 1);
                },
                cdf: (x, params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    if (x <= x0) return 0;
                    return 1 - Math.pow(x0/x, alpha);
                },
                stats: (params) => {
                    const alpha = params.alpha, x0 = params.x0;
                    return {
                        mean: alpha > 1 ? (alpha * x0) / (alpha - 1) : 'Undefined',
                        variance: alpha > 2 ? (x0*x0 * alpha) / ((alpha - 1)*(alpha - 1) * (alpha - 2)) : 'Undefined',
                        skewness: alpha > 3 ? (2*(alpha + 1)/(alpha - 3)) * Math.sqrt((alpha - 2)/alpha) : 'Undefined',
                        kurtosis: 'Complex calculation needed',
                        median: x0 * Math.pow(2, 1/alpha),
                        mode: x0
                    };
                }
            },

            logistic: {
                name: "Logistic Distribution",
                params: [
                    { name: "μ (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "s (scale)", id: "s", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Logistic distribution is used in growth models and as a smooth approximation to the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/s) * exp(-(x-μ)/s) / (1 + exp(-(x-μ)/s))²
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (location)</strong>: Location parameter</li>
                        <li><strong>s (scale)</strong>: Scale parameter (s > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Growth models</li>
                        <li>Regression analysis</li>
                        <li>Neural networks (sigmoid activation)</li>
                        <li>Demographic modeling</li>
                        <li>Risk assessment models</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric distribution with heavier tails than normal. Mean = μ, Variance = s²π²/3. Used as link function in logistic regression.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    const exp_term = Math.exp(-(x - mu) / s);
                    return (1/s) * exp_term / Math.pow(1 + exp_term, 2);
                },
                cdf: (x, params) => {
                    const mu = params.mu, s = params.s;
                    return 1 / (1 + Math.exp(-(x - mu) / s));
                },
                stats: (params) => {
                    const mu = params.mu, s = params.s;
                    return {
                        mean: mu,
                        variance: s * s * Math.PI * Math.PI / 3,
                        skewness: 0,
                        kurtosis: 6/5,
                        median: mu,
                        mode: mu
                    };
                }
            },

            laplace: {
                name: "Laplace Distribution",
                params: [
                    { name: "μ (location)", id: "mu", default: 0, min: -10, max: 10, step: 0.1 },
                    { name: "b (scale)", id: "b", default: 1, min: 0.1, max: 5, step: 0.1 }
                ],
                explanation: `
                    <p>The Laplace distribution (also called double exponential) has heavier tails than the normal distribution.</p>

                    <div class="formula">
                    f(x) = (1/(2b)) * exp(-|x-μ|/b)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (location)</strong>: Location parameter</li>
                        <li><strong>b (scale)</strong>: Scale parameter (b > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Modeling absolute deviations</li>
                        <li>Robust statistics</li>
                        <li>Signal processing</li>
                        <li>Finance (heavy tail modeling)</li>
                        <li>Atmospheric data analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Symmetric with sharper peak and heavier tails than normal. Mean = μ, Variance = 2b². Maximum entropy distribution for given mean absolute deviation.</p>
                `,
                pdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    return (1/(2*b)) * Math.exp(-Math.abs(x - mu)/b);
                },
                cdf: (x, params) => {
                    const mu = params.mu, b = params.b;
                    if (x < mu) {
                        return 0.5 * Math.exp((x - mu)/b);
                    } else {
                        return 1 - 0.5 * Math.exp((mu - x)/b);
                    }
                },
                stats: (params) => {
                    const mu = params.mu, b = params.b;
                    return {
                        mean: mu,
                        variance: 2 * b * b,
                        skewness: 0,
                        kurtosis: 3,
                        median: mu,
                        mode: mu
                    };
                }
            },

            chisquared: {
                name: "Chi-Squared Distribution",
                params: [
                    { name: "k (degrees of freedom)", id: "k", default: 5, min: 0.1, max: 20, step: 0.1 }
                ],
                explanation: `
                    <p>The Chi-Squared distribution arises from the sum of squares of independent standard normal random variables.</p>

                    <div class="formula">
                    f(x) = (1/(2^(k/2) * Γ(k/2))) * x^(k/2 - 1) * exp(-x/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>k (degrees of freedom)</strong>: Shape parameter (k > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Chi-squared tests for independence</li>
                        <li>Confidence interval construction</li>
                        <li>Goodness-of-fit tests</li>
                        <li>Variance estimation</li>
                        <li>Process capability analysis</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed for small k, approaches normal for large k. Mean = k, Variance = 2k. Support on (0,∞).</p>
                `,
                pdf: (x, params) => {
                    if (x < 0) return 0;
                    const k = params.k;
                    return (1 / (Math.pow(2, k/2) * math.gamma(k/2))) * Math.pow(x, k/2 - 1) * Math.exp(-x/2);
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const k = params.k;
                    return math.gammainc(k/2, x/2);
                },
                stats: (params) => {
                    const k = params.k;
                    return {
                        mean: k,
                        variance: 2 * k,
                        skewness: Math.sqrt(8/k),
                        kurtosis: 12/k,
                        median: k * Math.pow(1 - 2/(9*k), 3), // approximation
                        mode: k - 2
                    };
                }
            },

            fdist: {
                name: "F-Distribution (Snedecor F)",
                params: [
                    { name: "d₁ (numerator df)", id: "df1", default: 5, min: 0.1, max: 30, step: 0.1 },
                    { name: "d₂ (denominator df)", id: "df2", default: 10, min: 0.1, max: 30, step: 0.1 }
                ],
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    const num = math.gamma((df1+df2)/2) * Math.pow(df1/df2, df1/2) * Math.pow(x, df1/2 - 1);
                    const den = math.gamma(df1/2) * math.gamma(df2/2) * Math.pow(1 + (df1/df2)*x, (df1+df2)/2);
                    return num / den;
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    // Approximation using beta function relationship
                    const z = (df1 * x) / (df1 * x + df2);
                    return math.betainc(z, df1/2, df2/2);
                },
                stats: (params) => {
                    const df1 = params.df1, df2 = params.df2;
                    return {
                        mean: df2 > 2 ? df2 / (df2 - 2) : 'Undefined',
                        variance: df2 > 4 ? (2 * df2 * df2 * (df1 + df2 - 2)) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4)) : 'Undefined',
                        skewness: 'Complex calculation needed',
                        kurtosis: 'Complex calculation needed',
                        median: 'Approximation needed',
                        mode: (df1 - 2)/df1 * df2/(df2 + 2) // approximation
                    };
                },
                explanation: `
                    <p>The F-distribution (also known as Snedecor F-distribution or Fisher-Snedecor distribution) arises in the testing of whether two observed samples have the same variance.</p>

                    <div class="formula">
                    f(x) = (Γ((d₁+d₂)/2) / (Γ(d₁/2) * Γ(d₂/2))) * (d₁/d₂)^(d₁/2) * x^(d₁/2-1) * (1 + (d₁/d₂)x)^(-(d₁+d₂)/2)
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>d₁ (degrees of freedom numerator)</strong>: Shape parameter (d₁ > 0)</li>
                        <li><strong>d₂ (degrees of freedom denominator)</strong>: Shape parameter (d₂ > 0)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>ANOVA (Analysis of Variance)</li>
                        <li>F-test for equality of variances</li>
                        <li>Regression analysis (F-test)</li>
                        <li>General linear models</li>
                        <li>Quality control (variance testing)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, continuous, support on (0,∞). Mean = d₂/(d₂-2) for d₂>2. Variance = 2d₂²(d₁+d₂-2)/[d₁(d₂-2)²(d₂-4)] for d₂>4.</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    const num = math.gamma((df1+df2)/2) * Math.pow(df1/df2, df1/2) * Math.pow(x, df1/2 - 1);
                    const den = math.gamma(df1/2) * math.gamma(df2/2) * Math.pow(1 + (df1/df2)*x, (df1+df2)/2);
                    return num / den;
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const df1 = params.df1, df2 = params.df2;
                    // Approximation using beta function relationship
                    const z = (df1 * x) / (df1 * x + df2);
                    return math.betainc(z, df1/2, df2/2);
                },
                stats: (params) => {
                    const df1 = params.df1, df2 = params.df2;
                    return {
                        mean: df2 > 2 ? df2 / (df2 - 2) : 'Undefined',
                        variance: df2 > 4 ? (2 * df2 * df2 * (df1 + df2 - 2)) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4)) : 'Undefined',
                        skewness: 'Complex calculation needed',
                        kurtosis: 'Complex calculation needed',
                        median: 'Approximation needed',
                        mode: (df1 - 2)/df1 * df2/(df2 + 2) // approximation
                    };
                }
            },

            bivariate: {
                name: "Bivariate Normal Distribution",
                params: [
                    { name: "μ₁ (mean X)", id: "mu1", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "μ₂ (mean Y)", id: "mu2", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "σ₁ (std X)", id: "sigma1", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "σ₂ (std Y)", id: "sigma2", default: 1, min: 0.1, max: 3, step: 0.1 },
                    { name: "ρ (correlation)", id: "rho", default: 0.5, min: -0.99, max: 0.99, step: 0.01 }
                ],
                explanation: `
                    <p>The bivariate normal distribution is a generalization of the univariate normal distribution to two dimensions. It describes the joint behavior of two normally distributed random variables.</p>

                    <div class="formula">
                    f(x,y) = (1/(2πσ₁σ₂√(1-ρ²))) * exp[-1/(2(1-ρ²))] * [(x-μ₁)²/σ₁² - 2ρ(x-μ₁)(y-μ₂)/(σ₁σ₂) + (y-μ₂)²/σ₂²]
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ₁, μ₂</strong>: Means for X and Y variables</li>
                        <li><strong>σ₁, σ₂</strong>: Standard deviations for X and Y variables</li>
                        <li><strong>ρ</strong>: Correlation coefficient between X and Y (-1 ≤ ρ ≤ 1)</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Multivariate analysis</li>
                        <li>Portfolio optimization (asset returns)</li>
                        <li>Biological measurements (height & weight)</li>
                        <li>Economic indicators</li>
                        <li>Quality control (multiple measurements)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Elliptical contours, marginal distributions are normal, conditional distributions are normal. Covariance = ρσ₁σ₂.</p>
                `,
                // Note: Bivariate normal is 2D - we'll provide marginal distributions for 1D plots
                pdf: (x, params) => {
                    // For visualization, we'll show the marginal distribution for X
                    const mu = params.mu1, sigma = params.sigma1;
                    return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow((x - mu), 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    const mu = params.mu1, sigma = params.sigma1;
                    const z = (x - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    return {
                        mean: `${params.mu1} (X), ${params.mu2} (Y)`,
                        variance: `${params.sigma1}² (X), ${params.sigma2}² (Y)`,
                        skewness: '0 (for both marginals)',
                        kurtosis: '0 (for both marginals)',
                        median: `${params.mu1} (X), ${params.mu2} (Y)`,
                        mode: `${params.mu1} (X), ${params.mu2} (Y)`
                    };
                }
            },

            lognormal: {
                name: "Log-Normal Distribution",
                params: [
                    { name: "μ (log mean)", id: "mu", default: 0, min: -5, max: 5, step: 0.1 },
                    { name: "σ (log std dev)", id: "sigma", default: 1, min: 0.1, max: 3, step: 0.1 }
                ],
                explanation: `
                    <p>The log-normal distribution is a continuous probability distribution of a random variable whose logarithm is normally distributed. It arises when the logarithm of a quantity is normally distributed.</p>

                    <div class="formula">
                    f(x) = (1/(xσ√(2π))) * exp[-(ln(x)-μ)²/(2σ²)] for x > 0
                    </div>

                    <p><strong>Parameters:</strong></p>
                    <ul>
                        <li><strong>μ (log mean)</strong>: Mean of the logarithmic values</li>
                        <li><strong>σ (log std dev)</strong>: Standard deviation of the logarithmic values</li>
                    </ul>

                    <div class="applications">
                    <p><strong>Applications:</strong></p>
                    <ul>
                        <li>Stock prices (Black-Scholes model)</li>
                        <li>Particle sizes in materials</li>
                        <li>Income distributions</li>
                        <li>Survival times with multiplicative effects</li>
                        <li>Environmental concentrations</li>
                        <li>Reliability (failure times with multiple factors)</li>
                    </ul>
                    </div>

                    <p><strong>Properties:</strong> Right-skewed, support on (0,∞). Mean = exp(μ + σ²/2), Variance = exp(2μ + σ²)(exp(σ²) - 1). Median = exp(μ).</p>
                `,
                pdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const logx = Math.log(x);
                    return (1 / (x * sigma * Math.sqrt(2 * Math.PI))) *
                           Math.exp(-Math.pow(logx - mu, 2) / (2 * Math.pow(sigma, 2)));
                },
                cdf: (x, params) => {
                    if (x <= 0) return 0;
                    const mu = params.mu, sigma = params.sigma;
                    const z = (Math.log(x) - mu) / sigma;
                    return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
                },
                stats: (params) => {
                    const mu = params.mu, sigma = params.sigma;
                    return {
                        mean: Math.exp(mu + sigma * sigma / 2),
                        variance: Math.exp(2*mu + sigma*sigma) * (Math.exp(sigma*sigma) - 1),
                        skewness: (Math.exp(sigma*sigma) + 2) * Math.sqrt(Math.exp(sigma*sigma) - 1),
                        kurtosis: Math.exp(4*sigma*sigma) + 2*Math.exp(3*sigma*sigma) + 3*Math.exp(2*sigma*sigma) - 6,
                        median: Math.exp(mu),
                        mode: Math.exp(mu - sigma*sigma)
                    };
                }
            }
        };

// Global variables for data analysis
let charts = {};
let currentDistribution = null;

// Distribution definitions with parameters and explanations
function showTab(tabName) {
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });

    document.querySelectorAll('.nav-tabs button').forEach(btn => {
        btn.classList.remove('active');
    });

    document.getElementById(tabName).classList.add('active');
    event.target.classList.add('active');

    // Render main chart when switching to visualizations
    if (tabName === 'visualizations' && currentDistribution) {
        renderMainChart();
    }
}

function loadDistribution() {
    const select = document.getElementById('distributionSelect');
    const distName = select.value;

    if (!distName || !distributions[distName]) {
        console.warn('Distribution not found:', distName);
        return;
    }

    currentDistribution = distributions[distName];
    console.log('Loading distribution:', currentDistribution.name);
    
    // Update title if element exists
    const titleElement = document.getElementById('distTitle');
    if (titleElement) {
        titleElement.textContent = currentDistribution.name;
    }
    
    renderParameters();
    updateStatistics();
    
    // Only render charts if we're not in the parameters tab
    const activeTab = document.querySelector('.tab-panel.active');
    if (activeTab && activeTab.id === 'visualizations') {
        renderMainChart();
    }
    
    // Only render explanation if we're in the explanations tab
    if (activeTab && activeTab.id === 'explanations') {
        renderExplanation();
    }
}

function renderParameters() {
    const container = document.getElementById('paramsContainer');
    container.innerHTML = '';

    currentDistribution.params.forEach(param => {
        const control = document.createElement('div');
        control.className = 'param-control';
        control.innerHTML = `
            <label for="${param.id}">${param.name}</label>
            <input type="number" id="${param.id}" value="${param.default}"
                   min="${param.min}" max="${param.max}" step="${param.step}"
                   oninput="updateStatistics(); renderCharts()">
        `;
        container.appendChild(control);
    });
}

function getCurrentParams() {
    const params = {};
    if (!currentDistribution) return params;

    currentDistribution.params.forEach(param => {
        const input = document.getElementById(param.id);
        params[param.id] = parseFloat(input ? input.value : param.default) || param.default;
    });
    return params;
}

function updateStatistics() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    try {
        const stats = currentDistribution.stats(params);
        const container = document.getElementById('statsContainer');
        container.innerHTML = `
            <div class="stat-card">
                <div class="value">${stats.mean.toFixed ? stats.mean.toFixed(3) : stats.mean}</div>
                <div class="label">Mean (μ)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.variance.toFixed ? stats.variance.toFixed(3) : stats.variance}</div>
                <div class="label">Variance (σ²)</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.skewness.toFixed ? stats.skewness.toFixed(3) : stats.skewness}</div>
                <div class="label">Skewness</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.kurtosis.toFixed ? stats.kurtosis.toFixed(3) : stats.kurtosis}</div>
                <div class="label">Kurtosis</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.median.toFixed ? stats.median.toFixed(3) : stats.median}</div>
                <div class="label">Median</div>
            </div>
            <div class="stat-card">
                <div class="value">${stats.mode.toFixed ? stats.mode.toFixed(3) : stats.mode}</div>
                <div class="label">Mode</div>
            </div>
        `;
    } catch (e) {
        console.error('Error calculating statistics:', e);
        document.getElementById('statsContainer').innerHTML = '<div class="error">Error calculating statistics</div>';
    }
}

function renderCharts() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    const isDiscrete = currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') ||
                      currentDistribution.name.includes('Geometric') || currentDistribution.name.includes('Hypergeometric') ||
                      currentDistribution.name.includes('Negative Binomial');

    let xMin, xMax, step;
    let xValues = [], pdfValues = [], cdfValues = [];

    try {
        if (isDiscrete) {
            // Discrete distributions: use integer values
            xMin = 0;
            xMax = currentDistribution.name.includes('Binomial') ? params.n :
                   currentDistribution.name.includes('Geometric') ? Math.min(params.lambda * 3, 20) :
                   currentDistribution.name.includes('Hypergeometric') ? Math.min(params.n, 20) :
                   Math.min(params.lambda * 3, params.lambda * 2 + 10);

            for (let x = xMin; x <= xMax; x++) {
                xValues.push(x);
                pdfValues.push(currentDistribution.pmf ? currentDistribution.pmf(x, params) : 0);
                cdfValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
            }
        } else {
            // Continuous distributions: use smooth curve
            if (currentDistribution.name.includes('Beta') || currentDistribution.name.includes('Uniform')) {
                xMin = currentDistribution.name.includes('Uniform') ? params.a : 0;
                xMax = currentDistribution.name.includes('Uniform') ? params.b : 1;
                step = 0.02;
            } else {
                const range = Math.max(Math.abs(params.mu || 0) + 3 * Math.abs(params.sigma || 1), 5);
                xMin = -range;
                xMax = range;
                step = Math.max(range / 50, 0.1);
            }

            for (let x = xMin; x <= xMax; x += step) {
                xValues.push(Math.round(x * 100) / 100);
                pdfValues.push(currentDistribution.pdf ? currentDistribution.pdf(x, params) : 0);
                cdfValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
            }
        }

        // PDF Chart
        const pdfCtx = document.getElementById('pdfChart').getContext('2d');
        if (charts.pdf) charts.pdf.destroy();
        charts.pdf = new Chart(pdfCtx, {
            type: isDiscrete ? 'bar' : 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: isDiscrete ? 'Probability Mass' : 'Probability Density',
                    data: pdfValues,
                    borderColor: isDiscrete ? '#10b981' : '#10b981',
                    backgroundColor: isDiscrete ? 'rgba(16, 185, 129, 0.6)' : 'rgba(16, 185, 129, 0.1)',
                    fill: !isDiscrete,
                    borderWidth: 2,
                    pointRadius: isDiscrete ? 0 : 0,
                    pointHoverRadius: isDiscrete ? 4 : 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'x' },
                        type: isDiscrete ? 'category' : 'linear'
                    },
                    y: {
                        title: { display: true, text: isDiscrete ? 'Probability' : 'Density' },
                        beginAtZero: true
                    }
                },
                plugins: {
                    title: { display: true, text: isDiscrete ? 'Probability Mass Function' : 'Probability Density Function' }
                }
            }
        });

        // CDF Chart
        const cdfCtx = document.getElementById('cdfChart').getContext('2d');
        if (charts.cdf) charts.cdf.destroy();
        charts.cdf = new Chart(cdfCtx, {
            type: 'line',
            data: {
                labels: xValues,
                datasets: [{
                    label: 'Cumulative Probability',
                    data: cdfValues,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    fill: true,
                    borderWidth: 2,
                    pointRadius: isDiscrete ? 3 : 0,
                    pointHoverRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'x' } },
                    y: {
                        title: { display: true, text: 'Cumulative Probability' },
                        min: 0, max: 1
                    }
                },
                plugins: {
                    title: { display: true, text: 'Cumulative Distribution Function' }
                }
            }
        });
    } catch (e) {
        console.error('Error rendering charts:', e);
        // Clear canvases on error
        const pdfCanvas = document.getElementById('pdfChart');
        const cdfCanvas = document.getElementById('cdfChart');
        if (pdfCanvas) pdfCanvas.getContext('2d').clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        if (cdfCanvas) cdfCanvas.getContext('2d').clearRect(0, 0, cdfCanvas.width, cdfCanvas.height);
    }
}

function renderExplanation() {
    const container = document.getElementById('explanationContent');
    container.innerHTML = currentDistribution.explanation;
}

// Global variables for data analysis
let currentData = [];

// Simplified theme management (no toggle button in this demo)
function initTheme() {
    // Set a light theme by default since we don't have a theme toggle
    document.body.removeAttribute('data-theme');
}

// Data input and analysis functions
function changeDataMethod() {
    const method = document.getElementById('dataMethodSelect').value;

    // Highlight the selected method - all controls are now always visible
    const controls = ['uploadControls', 'randomControls', 'manualControls'];
    controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            if (id.includes(method)) {
                element.style.border = '2px solid #4CAF50';
                element.style.background = 'rgba(76, 175, 80, 0.05)';
            } else {
                element.style.border = '1px solid #ddd';
                element.style.background = 'rgba(255,255,255,0.9)';
            }
        }
    });

    console.log('Data method changed to:', method);
}

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileType = file.name.split('.').pop().toLowerCase();

    if (fileType === 'csv') {
        parseCSVFile(file);
    } else if (fileType === 'xlsx' || fileType === 'xls') {
        parseExcelFile(file);
    } else {
        alert('Please upload a CSV or Excel file.');
    }
}

function parseCSVFile(file) {
    Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        complete: function(results) {
            if (results.errors.length > 0) {
                console.error('CSV parsing errors:', results.errors);
                alert('Error parsing CSV file.');
                return;
            }

            const columns = Object.keys(results.data[0] || {});
            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            columns.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                columnSelect.appendChild(option);
            });

            window.parsedData = results.data.filter(row =>
                Object.values(row).some(val =>
                    typeof val === 'number' && !isNaN(val)
                )
            );

            alert(`File parsed successfully! Found ${columns.length} columns and ${window.parsedData.length} rows with numeric data.`);
        },
        error: function(error) {
            console.error('CSV parsing error:', error);
            alert('Error parsing CSV file: ' + error.message);
        }
    });
}

function parseExcelFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });

            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                defval: null
            });

            if (jsonData.length === 0) {
                alert('Excel file is empty.');
                return;
            }

            const headers = jsonData[0];
            const rows = jsonData.slice(1);

            const objectData = rows.map(row => {
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = row[i];
                });
                return obj;
            });

            window.parsedData = objectData;

            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Select a column...</option>';

            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                columnSelect.appendChild(option);
            });

            alert(`Excel file parsed successfully! Found ${headers.length} columns and ${rows.length} rows.`);
        } catch (error) {
            console.error('Excel parsing error:', error);
            alert('Error parsing Excel file: ' + error.message);
        }
    };

    reader.readAsArrayBuffer(file);
}

function processUploadedData() {
    const columnName = document.getElementById('columnSelect').value;
    if (!columnName || !window.parsedData) {
        alert('Please select a column and ensure data is loaded.');
        return;
    }

    const rawData = window.parsedData
        .map(row => row[columnName])
        .filter(val => typeof val === 'number' && !isNaN(val));

    if (rawData.length === 0) {
        alert('No valid numeric data found in the selected column.');
        return;
    }

    currentData = rawData;
    analyzeData(currentData);
}

function generateRandomData() {
    if (!currentDistribution) {
        alert('Please select a distribution first.');
        return;
    }

    const sampleSize = Math.min(parseInt(document.getElementById('sampleSize').value) || 100, 5000); // Cap sample size
    const params = getCurrentParams();
    const randomData = [];

    try {
        for (let i = 0; i < sampleSize; i++) {
            let value;

            switch (currentDistribution.name) {
                case 'Normal Distribution':
                    // Box-Muller transform
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    value = params.mu + z * Math.sqrt(params.sigma);
                    break;

                case 'Poisson Distribution':
                    // Knuth's algorithm for Poisson random variables
                    const lambda = params.lambda;
                    if (lambda < 30) {
                        // Direct method for small lambda
                        const L = Math.exp(-lambda);
                        let k = 0, p = 1;
                        do {
                            k++;
                            p *= Math.random();
                        } while (p > L);
                        value = k - 1;
                    } else {
                        // Normal approximation for large lambda
                        const normal = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                        value = Math.round(lambda + Math.sqrt(lambda) * normal);
                    }
                    break;

                case 'Binomial Distribution':
                    // Generate as sum of Bernoulli trials
                    let successCount = 0;
                    for (let j = 0; j < params.n; j++) {
                        if (Math.random() < params.p) successCount++;
                    }
                    value = successCount;
                    break;

                case 'Beta Distribution':
                    // Use acceptance-rejection or approximation
                    // For simplicity, use order statistics approximation
                    const uniform1 = Math.random();
                    const uniform2 = Math.random();
                    value = uniform1 * params.alpha + uniform2 * params.beta;
                    value = Math.max(0, Math.min(1, value / 2)); // Scale to [0,1] approximately
                    break;

                case 'Gamma Distribution':
                    // Marsaglia and Tsang method (simplified)
                    const k_shape = params.k;
                    const theta_scale = params.theta;

                    if (k_shape < 1) {
                        // Use acceptance-rejection for shape < 1
                        const u = Math.random();
                        const v = Math.random();
                        value = theta_scale * Math.pow(u, 1/k_shape) * Math.pow(-Math.log(v), (k_shape-1)/k_shape);
                    } else {
                        // Use Ahrens-Dieter acceptance-rejection
                        const d = k_shape - 1/3;
                        let x, v;
                        do {
                            do {
                                x = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                                v = 1 + x / Math.sqrt(d);
                            } while (v <= 0);
                            v = v * v * v;
                            const u = Math.random();
                            if (u < 1 - 0.0331 * x * x * x * x) break;
                            if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) break;
                        } while (true);
                        value = d * v * theta_scale;
                    }
                    break;

                case 'Geometric Distribution':
                    // Inverse transform sampling
                    value = Math.ceil(Math.log(Math.random()) / Math.log(1 - params.p));
                    break;

                case 'Hypergeometric Distribution':
                    // Approximation using binomial for large populations
                    const prob = params.n * params.K / (params.N * (params.N - params.n));
                    let successes = 0;
                    for (let j = 0; j < params.n; j++) {
                        if (Math.random() < prob) successes++;
                    }
                    value = successes;
                    break;

                case 'Student-t Distribution':
                    // Normal/Z divided by sqrt(Chisquare/df)
                    const normal = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                    // Generate chi-squared by summing squares of normal variables
                    let chi2 = 0;
                    for (let j = 0; j < Math.floor(params.df); j++) {
                        const norm = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                        chi2 += norm * norm;
                    }
                    value = normal / Math.sqrt(chi2 / params.df);
                    break;

                case 'Weibull Distribution':
                    // Inverse transform
                    value = params.lambda * Math.pow(-Math.log(Math.random()), 1/params.k);
                    break;

                case 'Uniform Distribution':
                    // Direct sampling
                    value = params.a + (params.b - params.a) * Math.random();
                    break;

                case 'Exponential Distribution':
                    // Memoryless property
                    value = -Math.log(Math.random()) / params.lambda;
                    break;

                case 'Chi-Squared Distribution':
                    // Sum of squares of normal variables
                    let chi = 0;
                    for (let j = 0; j < Math.floor(params.k); j++) {
                        const normal = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                        chi += normal * normal;
                    }
                    value = chi;
                    break;

                default:
                    // Fallback to uniform [0,1] scaled to distribution range
                    const range = params.sigma ? params.mu + 4 * params.sigma : params.lambda ? 4 * params.lambda : 10;
                    value = (Math.random() - 0.5) * 2 * range;
                    break;
            }

            if (isFinite(value) && !isNaN(value)) {
                randomData.push(Math.round(value * 10000) / 10000); // Round to 4 decimal places
            } else {
                randomData.push(0); // Fallback
            }
        }

        currentData = randomData;
        analyzeData(currentData);
        console.log(`Generated ${sampleSize} random samples from ${currentDistribution.name}`);

    } catch (error) {
        console.error('Error generating random data:', error);
        alert('Error generating random data: ' + error.message);
    }
}

function processManualData() {
    const manualText = document.getElementById('manualDataInput').value.trim();
    if (!manualText) {
        alert('Please enter some data.');
        return;
    }

    try {
        const values = manualText.split(',')
            .map(s => s.trim())
            .map(s => parseFloat(s))
            .filter(n => !isNaN(n));

        if (values.length === 0) {
            alert('No valid numeric values found.');
            return;
        }

        currentData = values;
        analyzeData(currentData);
    } catch (error) {
        alert('Error parsing manual data: ' + error.message);
    }
}

function analyzeData(data) {
    if (data.length === 0) return;

    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
    const stdDev = Math.sqrt(variance);
    const skewness = calculateSkewness(data, mean, stdDev);
    const median = calculateMedian(data);

    displayDataAnalysisResults(data.length, mean, stdDev, skewness, median);
    renderDataChart(data);
}

function calculateSkewness(data, mean, stdDev) {
    const n = data.length;
    const skewness = data.reduce((sum, val) => sum + Math.pow((val - mean) / stdDev, 3), 0) / n;
    return skewness;
}

function calculateMedian(data) {
    const sorted = [...data].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function displayDataAnalysisResults(count, mean, stdDev, skewness, median) {
    const kstest = performKSTest(currentData);
    const swtest = performShapiroWilkTest(currentData);
    const adtest = performAndersonDarlingTest(currentData);
    const jbtest = performJarqueBeraTest(currentData);

    document.getElementById('dataAnalysisResults').innerHTML = `
        <div class="stat-card">
            <div class="value">${count}</div>
            <div class="label">Data Points</div>
        </div>
        <div class="stat-card">
            <div class="value">${mean.toFixed(3)}</div>
            <div class="label">Sample Mean</div>
        </div>
        <div class="stat-card">
            <div class="value">${stdDev.toFixed(3)}</div>
            <div class="label">Std Dev</div>
        </div>
        <div class="stat-card">
            <div class="value">${skewness.toFixed(3)}</div>
            <div class="label">Skewness</div>
        </div>
        <div class="stat-card">
            <div class="value">${jbtest ? jbtest.skewness.toFixed(3) : '--'}</div>
            <div class="label">JB Skewness</div>
        </div>
        <div class="stat-card">
            <div class="value">${jbtest ? jbtest.kurtosis.toFixed(3) : '--'}</div>
            <div class="label">JB Kurtosis</div>
        </div>

        <h5 style="margin-top: 20px; margin-bottom: 10px; grid-column: 1 / -1;">🧪 Normality Tests</h5>

                    <div class="stat-card">
                        <div class="value">${swtest && typeof swtest.statistic === 'number' && isFinite(swtest.statistic) ? swtest.statistic.toFixed(3) : '--'}</div>
                        <div class="label">SW W-stat</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${swtest && swtest.pValue !== null && swtest.pValue !== undefined && isFinite(swtest.pValue) ? swtest.pValue.toFixed(3) : '--'}</div>
                        <div class="label">SW p-value</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${swtest && swtest.normality ? swtest.normality : '--'}</div>
                        <div class="label">SW Result</div>
                    </div>

                    <div class="stat-card">
                        <div class="value">${adtest && typeof adtest.statistic === 'number' && isFinite(adtest.statistic) ? adtest.statistic.toFixed(3) : '--'}</div>
                        <div class="label">AD A²-stat</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${adtest && adtest.pValue !== null && adtest.pValue !== undefined && isFinite(adtest.pValue) ? adtest.pValue.toFixed(3) : '--'}</div>
                        <div class="label">AD p-value</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${adtest && adtest.normality ? adtest.normality : '--'}</div>
                        <div class="label">AD Result</div>
                    </div>

                    <div class="stat-card">
                        <div class="value">${jbtest && typeof jbtest.statistic === 'number' && isFinite(jbtest.statistic) ? jbtest.statistic.toFixed(3) : '--'}</div>
                        <div class="label">JB χ²-stat</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${jbtest && jbtest.pValue !== null && jbtest.pValue !== undefined && isFinite(jbtest.pValue) ? jbtest.pValue.toFixed(3) : '--'}</div>
                        <div class="label">JB p-value</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${jbtest && jbtest.normality ? jbtest.normality : '--'}</div>
                        <div class="label">JB Result</div>
                    </div>

                    <h5 style="margin-top: 20px; margin-bottom: 10px; grid-column: 1 / -1;">📊 Goodness-of-Fit Tests</h5>

                    <div class="stat-card">
                        <div class="value">${kstest && typeof kstest.statistic === 'number' && isFinite(kstest.statistic) ? kstest.statistic.toFixed(3) : '--'}</div>
                        <div class="label">KS Statistic</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${kstest && kstest.pValue !== null && kstest.pValue !== undefined && isFinite(kstest.pValue) ? kstest.pValue.toFixed(3) : '--'}</div>
                        <div class="label">KS P-Value</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">${kstest && kstest.pValue !== null && kstest.pValue !== undefined && isFinite(kstest.pValue) && kstest.pValue > 0.05 ? 'Pass' : 'Fail'}</div>
                        <div class="label">KS α=0.05</div>
                    </div>
    `;

    displayFittingResults();
}

// Statistical Tests Implementation
function performShapiroWilkTest(data) {
    if (!data.length || data.length < 3 || data.length > 50) {
        // SW test requires 3 <= n <= 50
        return { statistic: null, pValue: null, note: 'Requires 3-50 observations' };
    }

    const n = data.length;
    const sortedData = [...data].sort((a, b) => a - b);
    const mean = sortedData.reduce((a, b) => a + b, 0) / n;

    // Calculate coefficients a_i (simplified version for small n)
    const a = calculateSWCoefficients(n);

    // Calculate W statistic
    let numerator = 0;
    for (let i = 0; i < n; i++) {
        numerator += a[i] * sortedData[i];
    }
    numerator *= numerator;

    let denominator = 0;
    for (let i = 0; i < n; i++) {
        denominator += Math.pow(sortedData[i] - mean, 2);
    }

    if (denominator === 0) return { statistic: null, pValue: null, note: 'No variance in data' };

    const W = numerator / denominator;

    // Calculate approximate p-value (simplified)
    const pValue = approximateSWPValue(W, n);

    return { statistic: W, pValue: pValue, normality: W > 0.9 ? 'normal' : W < 0.8 ? 'non-normal' : 'borderline' };
}

function calculateSWCoefficients(n) {
    // Simplified coefficient calculation for Shapiro-Wilk test
    // For more accuracy, these would be pre-computed from statistical tables
    const a = new Array(n);
    const m = Math.floor(n / 2);

    // Approximation based on polynomial formulas
    for (let i = 0; i < m; i++) {
        const j = i + 1;
        const phi = (n - 2*j + 1) / Math.sqrt(n * (n - 1));
        const poly = 1 - 2.706056e-4 * n + 0.884474 * phi - 0.0232 * phi * phi +
                    0.002961 * phi * phi * phi - 0.00028 * n * phi * phi;

        a[i] = poly / Math.sqrt(n * (n - 1) / 12);
        a[n - 1 - i] = a[i]; // symmetric
    }

    if (n % 2 === 1) {
        a[m] = 0; // middle coefficient (approximately 0)
    }

    return a;
}

function approximateSWPValue(W, n) {
    // Simplified p-value approximation
    // For accurate p-values, would need statistical tables or more complex calculation
    if (n <= 20) {
        // Rough approximation for small samples
        if (W > 0.99) return 0.99;
        if (W > 0.95) return 0.8;
        if (W > 0.90) return 0.5;
        if (W > 0.85) return 0.1;
        return 0.01;
    } else {
        // For larger samples, use normal approximation
        const z = Math.sqrt(n) * (W - 0.5) / Math.sqrt(0.5);
        return 0.5 * (1 + math.erf(z / Math.sqrt(2)));
    }
}

function performAndersonDarlingTest(data) {
    if (!data.length) return null;

    const n = data.length;
    const sortedData = [...data].sort((a, b) => a - b);
    const params = getCurrentParams();

    let A2 = 0;
    let mean = params.mu !== undefined ? params.mu : 0;
    let sigma = params.sigma !== undefined ? Math.sqrt(params.sigma) : 1;

    for (let i = 0; i < n; i++) {
        const z = (sortedData[i] - mean) / sigma;
        const cdf = 0.5 * (1 + math.erf(z / Math.sqrt(2)));
        const Fi = (i + 0.5) / n;

        const lnTerm1 = Math.log(cdf);
        const lnTerm2 = Math.log(1 - cdf);

        if (cdf > 0 && cdf < 1) {
            A2 += (2 * (i + 1) - 1) * (lnTerm1 + lnTerm2);
        }
    }

    A2 = -A2 / n - n;
    const pValue = A2 < 2 ? 0.99 : A2 < 3 ? 0.9 : A2 < 4 ? 0.7 : 0.01;

    return { statistic: A2, pValue: pValue, normality: A2 < 2 ? 'normal' : A2 > 3 ? 'non-normal' : 'borderline' };
}

function performJarqueBeraTest(data) {
    if (!data.length || data.length < 4) return null;

    const n = data.length;
    const mean = data.reduce((a, b) => a + b, 0) / n;

    // Calculate skewness
    let skewness = 0, kurtosis = 0;
    for (let i = 0; i < n; i++) {
        const diff = data[i] - mean;
        skewness += Math.pow(diff, 3);
        kurtosis += Math.pow(diff, 4);
    }

    const sigma2 = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
    const sigma = Math.sqrt(sigma2);

    skewness /= (n * Math.pow(sigma, 3));
    kurtosis /= (n * Math.pow(sigma, 4));

    // JB statistic
    const JB = (n / 6) * (Math.pow(skewness, 2) + Math.pow(kurtosis - 3, 2) / 4);

    // Approximate p-value using chi-square approximation (JB ~ chi²₂)
    // For chi-square with 2 df, we can use a simplified approximation
    const pValue = JB < 0.5 ? 0.9 : JB < 2 ? 0.5 : JB < 5 ? 0.1 : 0.01;

    return {
        statistic: JB,
        pValue: pValue,
        skewness: skewness,
        kurtosis: kurtosis,
        normality: JB < 6 ? 'normal' : JB > 10 ? 'non-normal' : 'borderline'
    };
}

function performKSTest(data) {
    if (!currentDistribution || !data.length) return null;

    const sortedData = [...data].sort((a, b) => a - b);
    const params = getCurrentParams();

    let maxDifference = 0;

    sortedData.forEach((value, index) => {
        const empiricalCDF = (index + 0.5) / sortedData.length;
        let theoreticalCDF = 0.5; // fallback

        try {
            if (currentDistribution.name === 'Normal Distribution') {
                const z = (value - params.mu) / Math.sqrt(params.sigma);
                theoreticalCDF = 0.5 * (1 + math.erf(z / Math.sqrt(2)));
            } else if (currentDistribution.name === 'Uniform Distribution') {
                theoreticalCDF = (value - params.a) / (params.b - params.a);
                theoreticalCDF = Math.max(0, Math.min(1, theoreticalCDF));
            }
        } catch (e) {
            console.warn('CDF calculation error:', e);
        }

        const difference = Math.abs(empiricalCDF - theoreticalCDF);
        maxDifference = Math.max(maxDifference, difference);
    });

    const pValue = maxDifference < 0.1 ? 0.8 : maxDifference < 0.2 ? 0.5 : 0.05;

    return { statistic: maxDifference, pValue: pValue };
}

function displayFittingResults() {
    const container = document.getElementById('fittingResults');
    const params = getCurrentParams();

    let resultsHTML = '<h4>📊 Fitted Parameters:</h4><ul>';

    Object.entries(params).forEach(([param, value]) => {
        resultsHTML += `<li><strong>${param}:</strong> ${value.toFixed(4)}</li>`;
    });

    resultsHTML += '</ul>';

    container.innerHTML = resultsHTML;
}

function renderDataChart(data) {
    // Create histogram using the main chart system
    const params = getCurrentParams();
    const titleElement = document.getElementById('chartTitle');
    titleElement.textContent = '📊 Data Histogram';

    // Switch to histogram mode
    currentChartType = 'histogram';
    renderMainChart();
}

// Chart type and style management
let currentChartType = 'pdf';
let currentChartStyle = 'default';

function changeChartType() {
    currentChartType = document.getElementById('chartTypeSelect').value;
    renderMainChart();
}

function changeChartStyle() {
    currentChartStyle = document.getElementById('styleSelect').value;
    renderMainChart();
}

function renderMainChart() {
    if (!currentDistribution) return;

    const params = getCurrentParams();
    const chartContainer = document.getElementById('mainChartContainer');
    const canvas = document.getElementById('mainChart');
    const titleElement = document.getElementById('chartTitle');

    // Use ChartManager to properly destroy existing chart
    ChartManager.destroy('mainChart');

    let chartData, chartOptions, chartType;

    // Generate chart based on type
    switch (currentChartType) {
        case 'pdf':
            ({ chartData, chartOptions, chartType } = createPDFChart(params));
            titleElement.textContent = '📈 Probability Density Function (PDF)';
            break;
        case 'cdf':
            ({ chartData, chartOptions, chartType } = createCDFChart(params));
            titleElement.textContent = '📊 Cumulative Distribution Function (CDF)';
            break;
        case 'histogram':
            ({ chartData, chartOptions, chartType } = createHistogramChart(params));
            titleElement.textContent = '📊 Histogram & Distribution Fit';
            break;
        case 'qqplot':
            ({ chartData, chartOptions, chartType } = createQQPlot(params));
            titleElement.textContent = '📉 Q-Q Plot';
            break;
        case 'boxplot':
            ({ chartData, chartOptions, chartType } = createBoxPlot(params));
            titleElement.textContent = '📦 Box Plot & Statistics';
            break;
        case 'scatter':
            ({ chartData, chartOptions, chartType } = createScatterPlot(params));
            titleElement.textContent = '🔸 Parameter Scatter Plot';
            break;
        case 'radar':
            ({ chartData, chartOptions, chartType } = createRadarComparison(params));
            titleElement.textContent = '🎯 Distribution Comparison';
            break;
    }

    // Apply style theme
    applyChartStyle(chartOptions);

    // Create new chart
    window.mainChart = new Chart(canvas, {
        type: chartType,
        data: chartData,
        options: chartOptions
    });
}

function getChartStyleConfig(style) {
    const themes = {
        default: {
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            borderColor: '#10b981',
            pointBackgroundColor: '#10b981',
            tension: 0.4,
            borderWidth: 2
        },
        professional: {
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            borderColor: '#3b82f6',
            pointBackgroundColor: '#3b82f6',
            tension: 0.1,
            borderWidth: 3,
            pointRadius: 0,
            pointHoverRadius: 6
        },
        vibrant: {
            backgroundColor: 'rgba(245, 158, 11, 0.2)',
            borderColor: '#f59e0b',
            pointBackgroundColor: '#f59e0b',
            tension: 0.6,
            borderWidth: 4,
            gradient: true
        },
        minimal: {
            backgroundColor: 'rgba(107, 114, 128, 0.05)',
            borderColor: '#6b7280',
            pointBackgroundColor: '#6b7280',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            grid: false
        }
    };
    return themes[style] || themes.default;
}

function applyChartStyle(options) {
    const style = getChartStyleConfig(currentChartStyle);

    // Apply to scales
    if (options.scales) {
        Object.keys(options.scales).forEach(scaleKey => {
            const scale = options.scales[scaleKey];
            if (scale.grid) {
                scale.grid.color = style.grid === false ? 'transparent' : 'rgba(0,0,0,0.1)';
                scale.grid.lineWidth = style.grid === false ? 0 : 1;
            }
            if (scale.ticks) {
                scale.ticks.color = 'var(--text-secondary)';
            }
        });
    }

    // Apply to plugins
    if (options.plugins && options.plugins.legend) {
        options.plugins.legend.labels.color = 'var(--text-primary)';
    }

    return options;
}

function createPDFChart(params) {
    const isDiscrete = currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') ||
                      currentDistribution.name.includes('Geometric') || currentDistribution.name.includes('Hypergeometric') ||
                      currentDistribution.name.includes('Negative Binomial');

    let xValues = [], yValues = [];

    if (isDiscrete) {
        const xMin = 0;
        const xMax = currentDistribution.name.includes('Binomial') ? params.n :
                    currentDistribution.name.includes('Geometric') ? Math.min(params.lambda * 3, 20) :
                    currentDistribution.name.includes('Hypergeometric') ? Math.min(params.n, 20) :
                    Math.min(params.lambda * 3, params.lambda * 2 + 10);

        for (let x = xMin; x <= xMax; x++) {
            xValues.push(x);
            yValues.push(currentDistribution.pmf ? currentDistribution.pmf(x, params) : 0);
        }
    } else {
        const range = Math.max(Math.abs(params.mu || 0) + 3 * Math.abs(params.sigma || 1), 5);
        const xMin = -range, xMax = range, step = Math.max(range / 100, 0.05);

        for (let x = xMin; x <= xMax; x += step) {
            xValues.push(Math.round(x * 100) / 100);
            yValues.push(currentDistribution.pdf ? currentDistribution.pdf(x, params) : 0);
        }
    }

    const style = getChartStyleConfig(currentChartStyle);

    return {
        chartType: isDiscrete ? 'bar' : 'line',
        chartData: {
            labels: xValues,
            datasets: [{
                label: isDiscrete ? 'Probability Mass' : 'Density',
                data: yValues,
                ...style
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: 'x', color: 'var(--text-primary)' },
                    type: isDiscrete ? 'category' : 'linear',
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                y: {
                    title: { display: true, text: isDiscrete ? 'Probability' : 'Density', color: 'var(--text-primary)' },
                    beginAtZero: true,
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white'
                }
            }
        }
    };
}

function createCDFChart(params) {
    const isDiscrete = currentDistribution.name.includes('Binomial') || currentDistribution.name.includes('Poisson') ||
                      currentDistribution.name.includes('Geometric') || currentDistribution.name.includes('Hypergeometric') ||
                      currentDistribution.name.includes('Negative Binomial');

    let xValues = [], yValues = [];

    if (isDiscrete) {
        const xMax = currentDistribution.name.includes('Binomial') ? params.n :
                    currentDistribution.name.includes('Geometric') ? Math.min(params.lambda * 3, 20) :
                    currentDistribution.name.includes('Hypergeometric') ? Math.min(params.n, 20) :
                    Math.min(params.lambda * 3, params.lambda * 2 + 10);

        for (let x = 0; x <= xMax; x++) {
            xValues.push(x);
            yValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
        }
    } else {
        const range = Math.max(Math.abs(params.mu || 0) + 3 * Math.abs(params.sigma || 1), 5);
        const xMin = -range, xMax = range, step = Math.max(range / 100, 0.05);

        for (let x = xMin; x <= xMax; x += step) {
            xValues.push(Math.round(x * 100) / 100);
            yValues.push(currentDistribution.cdf ? currentDistribution.cdf(x, params) : 0);
        }
    }

    const style = getChartStyleConfig(currentChartStyle);

    return {
        chartType: 'line',
        chartData: {
            labels: xValues,
            datasets: [{
                label: 'Cumulative Probability',
                data: yValues,
                fill: currentChartStyle !== 'minimal',
                ...style
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: 'x', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                y: {
                    title: { display: true, text: 'Cumulative Probability', color: 'var(--text-primary)' },
                    min: 0, max: 1,
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white'
                }
            }
        }
    };
}

function createHistogramChart(params) {
    if (!currentData || currentData.length === 0) {
        // Show distribution curve if no data
        return createPDFChart(params);
    }

    const data = currentData;
    const minVal = Math.min(...data);
    const maxVal = Math.max(...data);
    const binCount = Math.min(30, Math.ceil(Math.sqrt(data.length)));
    const binWidth = (maxVal - minVal) / binCount;
    const bins = Array(binCount).fill(0);

    data.forEach(value => {
        const binIndex = Math.min(binCount - 1, Math.floor((value - minVal) / binWidth));
        bins[binIndex]++;
    });

    const binLabels = [];
    for (let i = 0; i < binCount; i++) {
        const binStart = minVal + i * binWidth;
        const binEnd = binStart + binWidth;
        binLabels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
    }

    // Generate distribution curve overlay
    const curvePoints = [];
    const step = binWidth / 10;
    for (let i = 0; i < binCount; i++) {
        const x = minVal + i * binWidth + binWidth / 2;
        let density = 0;
        try {
            density = currentDistribution.pdf ? currentDistribution.pdf(x, params) : 0;
        } catch (e) {
            density = 0;
        }
        curvePoints.push({ x: x, y: density * data.length * binWidth });
    }

    const style1 = getChartStyleConfig(currentChartStyle);
    const style2 = getChartStyleConfig('vibrant'); // Different style for the fit line

    return {
        chartType: 'bar',
        chartData: {
            labels: binLabels,
            datasets: [{
                label: 'Data Histogram',
                data: bins,
                backgroundColor: style1.backgroundColor,
                borderColor: style1.borderColor,
                borderWidth: 1,
                yAxisID: 'y'
            }, {
                label: 'Distribution Fit',
                data: curvePoints.map(p => p.y),
                type: 'line',
                borderColor: style2.borderColor,
                backgroundColor: style2.backgroundColor,
                fill: false,
                pointRadius: style1.pointRadius || 0,
                tension: style1.tension || 0.4,
                yAxisID: 'y'
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: 'Value Range', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: { display: true, text: 'Frequency', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white'
                }
            }
        }
    };
}

function createQQPlot(params) {
    if (!currentData || currentData.length === 0) {
        return createPDFChart(params); // fallback
    }

    const data = [...currentData].sort((a, b) => a - b);
    const theoreticalQuantiles = [];
    const sampleQuantiles = [];

    // Calculate theoretical quantiles at various probabilities
    const probabilities = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99];

    probabilities.forEach(p => {
        const index = Math.floor(p * (data.length - 1));
        sampleQuantiles.push(data[index]);

        // Theoretical quantile (simplified - need proper quantile function)
        let theoreticalValue = params.mu || 0;
        if (currentDistribution.name === 'Normal Distribution') {
            const z = math.erfinv(2 * p - 1) * Math.sqrt(2);
            theoreticalValue = params.mu + z * Math.sqrt(params.sigma);
        }
        theoreticalQuantiles.push(theoreticalValue);
    });

    const style1 = getChartStyleConfig(currentChartStyle);
    const style2 = getChartStyleConfig('professional'); // Different style for reference line

    return {
        chartType: 'scatter',
        chartData: {
            datasets: [{
                label: 'Q-Q Plot',
                data: sampleQuantiles.map((y, i) => ({ x: theoreticalQuantiles[i], y: y })),
                backgroundColor: style1.pointBackgroundColor || style1.borderColor,
                borderColor: style1.borderColor,
                pointRadius: style1.pointRadius || 6,
                pointHoverRadius: style1.pointHoverRadius || 8
            }, {
                label: 'Reference Line',
                data: [
                    { x: Math.min(...theoreticalQuantiles), y: Math.min(...theoreticalQuantiles) },
                    { x: Math.max(...theoreticalQuantiles), y: Math.max(...theoreticalQuantiles) }
                ],
                type: 'line',
                borderColor: style2.borderColor,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: 'Theoretical Quantiles', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                y: {
                    title: { display: true, text: 'Sample Quantiles', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white',
                    callbacks: {
                        label: (context) => {
                            return `Theoretical: ${context.parsed.x.toFixed(3)}, Sample: ${context.parsed.y.toFixed(3)}`;
                        }
                    }
                }
            }
        }
    };
}

function createBoxPlot(params) {
    if (!currentData || currentData.length === 0) {
        return createPDFChart(params); // fallback
    }

    const data = currentData;
    const sorted = [...data].sort((a, b) => a - b);
    const q1 = sorted[Math.floor(sorted.length * 0.25)];
    const median = sorted[Math.floor(sorted.length * 0.5)];
    const q3 = sorted[Math.floor(sorted.length * 0.75)];
    const iqr = q3 - q1;
    const min = Math.min(...data);
    const max = Math.max(...data);

    const style = getChartStyleConfig(currentChartStyle);

    // Create a simple bar chart to represent box plot visually
    return {
        chartType: 'bar',
        chartData: {
            labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
            datasets: [{
                label: 'Box Plot Statistics',
                data: [min, q1, median, q3, max],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.6)',
                    'rgba(54, 162, 235, 0.6)', 
                    'rgba(255, 206, 86, 0.6)',
                    'rgba(75, 192, 192, 0.6)',
                    'rgba(153, 102, 255, 0.6)'
                ],
                borderColor: [
                    'rgba(255, 99, 132, 1)',
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)'
                ],
                borderWidth: 2
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    title: { display: true, text: 'Value', color: 'var(--text-primary)' },
                    beginAtZero: false,
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                x: {
                    title: { display: true, text: 'Statistics', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white',
                    callbacks: {
                        afterLabel: function(context) {
                            if (context.label === 'Q1') return `25th percentile`;
                            if (context.label === 'Median') return `50th percentile`;
                            if (context.label === 'Q3') return `75th percentile`;
                            if (context.label === 'Min') return `Minimum value`;
                            if (context.label === 'Max') return `Maximum value`;
                            return '';
                        }
                    }
                }
            }
        }
    };
}

function createScatterPlot(params) {
    if (!currentData || currentData.length === 0) {
        return createPDFChart(params); // fallback
    }

    // Create parameter vs value scatter plot
    const scatterData = [];
    const data = currentData;

    // Use different parameters for x-axis
    let xParam = 'index'; // default
    let xValues = data.map((_, i) => i + 1);

    // Try to use meaningful parameter for x-axis
    if (currentDistribution.name === 'Normal Distribution') {
        xParam = 'μ (mean)';
        xValues = data.map(() => params.mu + (Math.random() - 0.5) * params.sigma);
    }

    data.forEach((y, i) => {
        scatterData.push({ x: xValues[i], y: y });
    });

    const style = getChartStyleConfig(currentChartStyle);

    return {
        chartType: 'scatter',
        chartData: {
            datasets: [{
                label: `Value vs ${xParam}`,
                data: scatterData,
                backgroundColor: style.pointBackgroundColor || style.borderColor,
                borderColor: style.borderColor,
                pointRadius: style.pointRadius || 3,
                pointHoverRadius: style.pointHoverRadius || 6
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: { display: true, text: xParam, color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                },
                y: {
                    title: { display: true, text: 'Data Value', color: 'var(--text-primary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    ticks: { color: 'var(--text-secondary)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white'
                }
            }
        }
    };
}

function createRadarComparison(params) {
    // Compare different aspects of the distribution
    const stats = currentDistribution.stats(params);
    const style = getChartStyleConfig(currentChartStyle);

    return {
        chartType: 'radar',
        chartData: {
            labels: ['Mean', 'Variance', 'Skewness', 'Kurtosis', 'Symmetry'],
            datasets: [{
                label: currentDistribution.name,
                data: [
                    Math.abs(stats.mean) / 10, // normalized
                    Math.min(stats.variance / 10, 1),
                    (stats.skewness + 3) / 6, // normalize skewness
                    Math.min(stats.kurtosis / 10, 1),
                    0.8 // symmetry measure
                ],
                backgroundColor: style.backgroundColor.replace('0.1', '0.2'), // More opaque for radar
                borderColor: style.borderColor,
                borderWidth: style.borderWidth || 2,
                pointBackgroundColor: style.pointBackgroundColor || style.borderColor,
                pointRadius: style.pointRadius || 4
            }]
        },
        chartOptions: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                r: {
                    beginAtZero: true,
                    max: 1,
                    ticks: { color: 'var(--text-secondary)' },
                    grid: { color: 'rgba(0,0,0,0.1)' },
                    angleLines: { color: 'rgba(0,0,0,0.1)' }
                }
            },
            plugins: {
                legend: { display: true, labels: { color: 'var(--text-primary)' } },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: 'white',
                    bodyColor: 'white'
                }
            }
        }
    };
}

function exportChart() {
    if (!window.mainChart) return;

    const canvas = document.getElementById('mainChart');
    const link = document.createElement('a');
    link.download = `${currentChartType}-chart-${new Date().toISOString().slice(0,10)}.png`;
    link.href = canvas.toDataURL();
    link.click();
}

function toggleFullscreen() {
    const container = document.getElementById('mainChartContainer');
    if (container.classList.contains('fullscreen')) {
        container.classList.remove('fullscreen');
    } else {
        container.classList.add('fullscreen');
        // Scroll to chart
        container.scrollIntoView({ behavior: 'smooth' });
    }
}

function showInsights() {
    const panel = document.getElementById('insightsPanel');
    const content = document.getElementById('insightsContent');

    if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';

        // Generate insights based on current distribution
        let insights = '<h5>📊 Distribution Insights</h5>';

        if (currentDistribution && currentData.length > 0) {
            const stats = currentDistribution.stats(getCurrentParams());
            const dataStats = calculateDataStats(currentData);

            insights += '<div style="display: grid; gap: 10px; margin-top: 15px;">';
            insights += `<div><strong>Sample Size:</strong> ${currentData.length}</div>`;
            insights += `<div><strong>Data Range:</strong> ${dataStats.min.toFixed(3)} to ${dataStats.max.toFixed(3)}</div>`;
            insights += `<div><strong>Goodness of Fit:</strong> KS test statistic = ${dataStats.ksStat?.toFixed(3) || 'N/A'}</div>`;

            if (Math.abs(stats.mean - dataStats.mean) < dataStats.std * 0.1) {
                insights += '<div style="color: #10b981;">✅ Distribution fit appears reasonable</div>';
            } else {
                insights += '<div style="color: #f59e0b;">⚠️ Consider different distribution or parameter adjustment</div>';
            }
        } else {
            insights += '<div>Upload data or select parameters to see insights</div>';
        }

        insights += '</div>';
        content.innerHTML = insights;

        // Scroll to insights
        panel.scrollIntoView({ behavior: 'smooth' });
    } else {
        panel.style.display = 'none';
    }
}

function calculateDataStats(data) {
    const n = data.length;
    const sorted = [...data].sort((a, b) => a - b);
    const mean = data.reduce((a, b) => a + b, 0) / n;
    const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
    const std = Math.sqrt(variance);

    return {
        mean: mean,
        std: std,
        min: sorted[0],
        max: sorted[n-1],
        median: sorted[Math.floor(n/2)],
        ksStat: performKSTest(data)?.statistic
    };
}

// Initialize application
document.addEventListener('DOMContentLoaded', function() {
    initTheme();
    
    // Set initial distribution and load it properly
    const select = document.getElementById('distributionSelect');
    if (select) {
        select.value = 'normal';
        // Make sure the distribution is loaded
        if (distributions && distributions.normal) {
            currentDistribution = distributions.normal;
            renderParameters();
            updateStatistics();
        }
    }
    
    changeDataMethod();
    
    console.log('Application initialized with Normal distribution');
});
    </script>
</body>
</html>
