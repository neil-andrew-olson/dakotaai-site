<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota AI Demos - Paper Plane Simulator</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .main-header {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #f9ca24, #a29bfe, #fd79a8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 1rem;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .zone-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 20px;
            font-family: 'Comic Sans MS', cursive;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .simulator-container {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            padding: 2rem;
            border-radius: 20px;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .simulator-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="%23ff6b6b" opacity="0.3"/><circle cx="80" cy="40" r="1.5" fill="%234ecdc4" opacity="0.4"/><circle cx="60" cy="80" r="1" fill="%23f9ca24" opacity="0.2"/><circle cx="10" cy="70" r="1.5" fill="%23a29bfe" opacity="0.3"/></svg>');
            pointer-events: none;
        }

        #simulator-canvas {
            width: 100%;
            height: 600px;
            border: 4px solid #2d3436;
            border-radius: 15px;
            background: linear-gradient(45deg, #74b9ff, #a29bfe);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 1.5rem;
            border-radius: 15px;
            margin: 2rem 0;
            backdrop-filter: blur(10px);
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .control-btn {
            background: linear-gradient(45deg, #ff7675, #fd79a8);
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 118, 117, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 118, 117, 0.4);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .instructions {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            padding: 1.5rem;
            border-radius: 15px;
            color: white;
            margin: 2rem 0;
        }

        .instructions h3 {
            margin-top: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ff7675;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #636e72;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .celebration {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #ff9ff3, #54a0ff);
            color: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: bounce 0.5s ease infinite alternate;
            display: none;
        }

        @keyframes bounce {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }

        .drawn-text {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            color: #2d3436;
        }

        /* Hand-drawn effect */
        .hand-drawn {
            position: relative;
        }

        .hand-drawn::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            border-radius: inherit;
            z-index: -1;
            filter: blur(1px);
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="nav-container">
                <div class="logo"><a href="../index.html"><img src="../DakotaAI_logo.png" alt="Dakota AI"></a></div>
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../about.html">About</a></li>
                    <li><a href="../services.html">Services</a></li>
                    <li><a href="index.html">Demos</a></li>
                    <li><a href="../contact.html">Contact</a></li>
                    <li><a href="../blog.html">Blog</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <section>
            <div class="container" style="max-width: 1200px; margin: 0 auto; padding: 2rem 1rem;">
                <h1 class="main-header drawn-text">‚úàÔ∏è Paper Plane World Adventures! ‚úàÔ∏è</h1>
                <p style="text-align: center; font-size: 1.3rem; color: #636e72; margin-bottom: 2rem; font-family: 'Comic Sans MS', cursive;">
                    Explore four magical worlds! Fly your paper plane through starry skies, sunny meadows, towering cities, and countryside farms! üåüüåªüèôÔ∏èüåæ
                </p>

                <div class="simulator-container">
                    <div class="zone-indicator" id="zone-indicator">üåå Night Sky Zone</div>
                    <canvas id="simulator-canvas"></canvas>
                </div>

                <div class="stats-panel">
                    <div class="stat-card">
                        <div class="stat-value" id="stars-count">0</div>
                        <div class="stat-label">Stars Collected</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="drawings-found">0</div>
                        <div class="stat-label">Drawings Found</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="flight-time">0</div>
                        <div class="stat-label">Flight Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tricks-done">0</div>
                        <div class="stat-label">Tricks</div>
                    </div>
                </div>

                <div class="controls-panel">
                    <h3 style="margin-top: 0; color: #2d3436; font-family: 'Comic Sans MS', cursive;">Flight Controls üéÆ</h3>
                    <div class="control-buttons">
                        <button class="control-btn" onclick="resetPlane()">üîÑ Reset Plane</button>
                        <button class="control-btn" onclick="toggleAutoPilot()">ü§ñ Auto Pilot</button>
                        <button class="control-btn" onclick="addWind()">üí® Add Wind</button>
                        <button class="control-btn" onclick="changeTheme()">üé® Change Colors</button>
                    </div>

                    <div style="margin-top: 1rem; color: #636e72;">
                        <strong>Controls:</strong> Mouse to look around ‚Ä¢ WASD or Arrow Keys to fly ‚Ä¢ Space to flap wings ‚Ä¢ E to spin
                    </div>
                </div>

                <div class="instructions">
                    <h3>Welcome to Paper Plane Adventures! üéâ</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem;">
                        <div>
                            <h4>üéØ Your Mission:</h4>
                            <ul>
                                <li>Fly your paper plane around the room</li>
                                <li>Collect all the floating stars üåü</li>
                                <li>Fly through the drawings on the walls üé®</li>
                                <li>Try fancy tricks like loops and spins! üåÄ</li>
                            </ul>
                        </div>
                        <div>
                            <h4>üìö Learn Physics:</h4>
                            <ul>
                                <li><strong>Lift:</strong> Speed makes you go up!</li>
                                <li><strong>Gravity:</strong> You slowly fall down</li>
                                <li><strong>Drag:</strong> Air slows you down</li>
                                <li><strong>Flap:</strong> Press SPACE to get a boost!</li>
                            </ul>
                        </div>
                        <div>
                            <h4>üèÜ Tips & Tricks:</h4>
                            <ul>
                                <li>Gain speed by diving downward</li>
                                <li>Use walls to bounce and change direction</li>
                                <li>Look for hidden drawings on walls</li>
                                <li>Try to collect all stars in under 2 minutes!</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="celebration" id="celebration-message">
                    üéâ AMAZING! You collected all the stars! üéâ
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h4>Dakota AI</h4>
                <p>Learning physics through play! Made with ‚ù§Ô∏è for curious kids and kids-at-heart.</p>
            </div>
        </div>
    </footer>

    <script>
        // Paper Plane World Simulator - Massive 3D World with Themed Zones
        let scene, camera, renderer;
        let plane, world;
        let stars = [];
        let flowers = [];
        let coins = [];
        let carrots = [];
        let collectibles = [];
        let currentZone = 'night';
        let zones = {
            night: { name: 'üåå Night Sky Zone', stars: 15, collected: 0 },
            meadow: { name: 'üåª Sunny Meadow Zone', stars: 12, collected: 0 },
            city: { name: 'üèôÔ∏è Cityscape Zone', stars: 10, collected: 0 },
            farmland: { name: 'üåæ Countryside Zone', stars: 8, collected: 0 }
        };

        let score = { stars: 0, flowers: 0, coins: 0, carrots: 0, tricks: 0 };
        let flightTime = 0;
        let lastTime = 0;
        let autoPilot = false;
        let windDirection = { x: 0, y: 0, z: 0 };
        let cameraOffset = { x: 0, y: 5, z: 10 };
        let cameraTarget = new THREE.Vector3();

        // Flight physics
        let velocity = { x: 0, y: 0, z: 0 };
        let rotation = { x: 0, y: 0, z: 0 };
        let speed = 0;
        let keys = {};
        let worldSize = 200; // Huge 200x200x200 world

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera - 3rd person following camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('simulator-canvas'), antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Start in night sky zone
            changeZone('night');

            // Create the massive world environment
            createMassiveWorld();

            // Paper plane
            createPaperPlane();

            // Create collectibles for current zone
            createZoneCollectibles();

            // Event listeners
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
        }

        function changeZone(zoneName) {
            currentZone = zoneName;
            const zoneData = zones[zoneName];

            // Update UI
            document.getElementById('zone-indicator').textContent = zoneData.name;

            // Update scene background and lighting
            updateZoneAtmosphere(zoneName);

            // Update fog
            updateFog(zoneName);

            score = { stars: 0, flowers: 0, coins: 0, carrots: 0, tricks: 0 };
            updateUI();
        }

        function updateZoneAtmosphere(zoneName) {
            switch(zoneName) {
                case 'night':
                    scene.background = new THREE.Color(0x000428);
                    break;
                case 'meadow':
                    scene.background = new THREE.Color(0x87CEEB);
                    break;
                case 'city':
                    scene.background = new THREE.Color(0x4169E1);
                    break;
                case 'farmland':
                    scene.background = new THREE.Color(0x98FB98);
                    break;
            }
        }

        function updateFog(zoneName) {
            switch(zoneName) {
                case 'night':
                    renderer.fog = new THREE.Fog(0x000428, 50, 400);
                    break;
                case 'meadow':
                    renderer.fog = new THREE.Fog(0x87CEEB, 100, 600);
                    break;
                case 'city':
                    renderer.fog = new THREE.Fog(0x4169E1, 30, 300);
                    break;
                case 'farmland':
                    renderer.fog = new THREE.Fog(0x98FB98, 150, 800);
                    break;
            }
        }

        function createMassiveWorld() {
            world = new THREE.Group();

            // Create basic terrain/ground for each zone
            createZoneTerrain();

            // Add ambient environmental objects
            createZoneEnvironment();

            scene.add(world);
        }

        function createZoneTerrain() {
            // Large ground plane for the zone
            const terrainGeometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
            const terrainMaterial = new THREE.MeshLambertMaterial({
                color: getTerrainColor(currentZone),
                transparent: true,
                opacity: 0.8
            });
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            world.add(terrain);

            // Add some rolling hills/features
            if (currentZone === 'meadow') {
                createRollingHills();
            } else if (currentZone === 'farmland') {
                createFarmTerrain();
            }
        }

        function getTerrainColor(zone) {
            switch(zone) {
                case 'night': return 0x2c3e50;
                case 'meadow': return 0x90EE90;
                case 'city': return 0x696969;
                case 'farmland': return 0x8B4513;
                default: return 0x808080;
            }
        }

        function createRollingHills() {
            for (let i = 0; i < 8; i++) {
                const hillGeometry = new THREE.SphereGeometry(15 + Math.random() * 10, 8, 6);
                const hillMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                hill.position.set(
                    (Math.random() - 0.5) * worldSize * 0.8,
                    -5,
                    (Math.random() - 0.5) * worldSize * 0.8
                );
                hill.scale.y = 0.3;
                world.add(hill);
            }
        }

        function createFarmTerrain() {
            // Create farm fields
            for (let i = 0; i < 4; i++) {
                const fieldGeometry = new THREE.PlaneGeometry(40, 40);
                const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                field.rotation.x = -Math.PI / 2;
                field.position.set(
                    (i % 2 - 0.5) * 60,
                    -0.1,
                    (Math.floor(i / 2) - 0.5) * 60
                );
                world.add(field);
            }
        }

        function createZoneEnvironment() {
            const envCount = getEnvObjectCount(currentZone);

            for (let i = 0; i < envCount; i++) {
                const obj = createEnvironmentalObject(currentZone);
                if (obj) {
                    obj.position.set(
                        (Math.random() - 0.5) * worldSize * 0.6,
                        getEnvObjectY(currentZone),
                        (Math.random() - 0.5) * worldSize * 0.6
                    );
                    world.add(obj);
                }
            }
        }

        function getEnvObjectCount(zone) {
            switch(zone) {
                case 'night': return 20; // Stars in sky
                case 'meadow': return 15; // Flowers, trees
                case 'city': return 12; // Buildings
                case 'farmland': return 8; // Farm animals, barns
                default: return 10;
            }
        }

        function getEnvObjectY(zone) {
            switch(zone) {
                case 'night': return Math.random() * 50 + 20; // Stars up high
                default: return Math.random() * 5 - 1; // Ground level
            }
        }

        function createEnvironmentalObject(zone) {
            switch(zone) {
                case 'night':
                    return createNightSkyObject();
                case 'meadow':
                    return createMeadowObject();
                case 'city':
                    return createCityObject();
                case 'farmland':
                    return createFarmObject();
                default:
                    return createBasicTree();
            }
        }

        function createNightSkyObject() {
            const types = ['star', 'moon', 'planet'];
            const type = types[Math.floor(Math.random() * types.length)];

            let geometry, material, mesh;

            switch(type) {
                case 'star':
                    geometry = new THREE.OctahedronGeometry(0.5, 0);
                    material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    break;
                case 'moon':
                    geometry = new THREE.CircleGeometry(3, 16);
                    material = new THREE.MeshBasicMaterial({ color: 0xffff99 });
                    break;
                case 'planet':
                    geometry = new THREE.SphereGeometry(2, 8, 6);
                    material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                    break;
            }

            mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function createMeadowObject() {
            const types = ['flower', 'tree', 'butterfly'];
            const type = types[Math.floor(Math.random() * types.length)];

            let geometry, material, mesh;

            switch(type) {
                case 'flower':
                    geometry = new THREE.ConeGeometry(0.5, 2, 6);
                    material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                    break;
                case 'tree':
                    geometry = new THREE.CylinderGeometry(0.5, 1, 8, 6);
                    material = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    break;
                case 'butterfly':
                    geometry = new THREE.PlaneGeometry(1, 1);
                    material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide });
                    break;
            }

            mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function createCityObject() {
            const buildingGeometry = new THREE.BoxGeometry(4, 10 + Math.random() * 20, 4);
            const buildingMaterial = new THREE.MeshLambertMaterial({
                color: Math.random() > 0.5 ? 0x888888 : 0x666666
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

            // Add windows
            for (let w = 0; w < Math.floor(buildingGeometry.parameters.height / 3); w++) {
                if (Math.random() > 0.3) {
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                    const windowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99 });
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(
                        (Math.random() - 0.5) * 2.5,
                        -buildingGeometry.parameters.height/2 + w * 3 + 1.5,
                        buildingGeometry.parameters.depth/2 + 0.01
                    );
                    building.add(window);
                }
            }

            return building;
        }

        function createFarmObject() {
            const types = ['barn', 'tractor', 'animal'];
            const type = types[Math.floor(Math.random() * types.length)];

            let geometry, material, mesh;

            switch(type) {
                case 'barn':
                    geometry = new THREE.BoxGeometry(8, 6, 12);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
                case 'tractor':
                    geometry = new THREE.BoxGeometry(2, 1.5, 4);
                    material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    break;
                case 'animal':
                    geometry = new THREE.CylinderGeometry(0.5, 0.8, 2, 6);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
            }

            mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function createBasicTree() {
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.5, 4, 6),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            const leaves = new THREE.Mesh(
                new THREE.SphereGeometry(2, 8, 6),
                new THREE.MeshLambertMaterial({ color: 0x228B22 })
            );
            leaves.position.y = 3;

            const tree = new THREE.Group();
            tree.add(trunk);
            tree.add(leaves);

            return tree;
        }

        function createRoom() {
            room = new THREE.Group();

            // Floor (carpet-like)
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshLambertMaterial({
                color: 0xffdab9,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            room.add(floor);

            // Walls
            const wallMaterial = new THREE.MeshLambertMaterial({
                color: 0xfff8dc,
                transparent: true,
                opacity: 0.8
            });

            // Back wall
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            backWall.position.z = -10;
            room.add(backWall);

            // Left wall
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            leftWall.position.x = -10;
            leftWall.rotation.y = Math.PI / 2;
            room.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
            rightWall.position.x = 10;
            rightWall.rotation.y = -Math.PI / 2;
            room.add(rightWall);

            // Ceiling
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), wallMaterial);
            ceiling.position.y = 5;
            ceiling.rotation.x = Math.PI / 2;
            room.add(ceiling);

            // Add some furniture (simple boxes)
            const bedGeometry = new THREE.BoxGeometry(4, 1, 6);
            const bedMaterial = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
            const bed = new THREE.Mesh(bedGeometry, bedMaterial);
            bed.position.set(-6, 0.5, -7);
            bed.castShadow = true;
            room.add(bed);

            const deskGeometry = new THREE.BoxGeometry(3, 1.5, 2);
            const deskMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const desk = new THREE.Mesh(deskGeometry, deskMaterial);
            desk.position.set(6, 0.75, -8);
            desk.castShadow = true;
            room.add(desk);

            scene.add(room);
        }

        function createPaperPlane() {
            plane = new THREE.Group();

            // Simple paper plane shape (triangle with wings)
            const bodyGeometry = new THREE.ConeGeometry(0.3, 1.2, 3);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            plane.add(body);

            // Wings
            const wingGeometry = new THREE.PlaneGeometry(2, 0.2);
            const wingMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.3, 0, 0);
            leftWing.rotation.y = Math.PI / 6;
            plane.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.3, 0, 0);
            rightWing.rotation.y = -Math.PI / 6;
            plane.add(rightWing);

            // Tail
            const tailGeometry = new THREE.PlaneGeometry(0.8, 0.3);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 0, -0.5);
            plane.add(tail);

            plane.position.set(0, 2, 0);
            plane.castShadow = true;
            scene.add(plane);
        }

        function createStars() {
            const starGeometry = new THREE.OctahedronGeometry(0.15, 0);
            const starMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });

            for (let i = 0; i < 10; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(
                    (Math.random() - 0.5) * 16,
                    Math.random() * 4 + 1,
                    (Math.random() - 0.5) * 16
                );
                star.userData = { collected: false, type: 'star' };
                stars.push(star);
                scene.add(star);
            }
        }

        function createWallDrawings() {
            // Child's drawings on walls (simple colored shapes)
            const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xa29bfe];

            // Back wall drawings
            for (let i = 0; i < 5; i++) {
                const drawing = new THREE.Group();

                // Random shapes
                const shapes = ['circle', 'square', 'triangle'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];

                let geometry;
                if (shape === 'circle') {
                    geometry = new THREE.CircleGeometry(0.5, 8);
                } else if (shape === 'square') {
                    geometry = new THREE.PlaneGeometry(1, 1);
                } else {
                    geometry = new THREE.ConeGeometry(0.5, 1, 3);
                    geometry.rotateX(Math.PI / 2);
                }

                const material = new THREE.MeshLambertMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.7
                });

                const mesh = new THREE.Mesh(geometry, material);
                drawing.add(mesh);
                drawing.position.set(
                    (Math.random() - 0.5) * 16,
                    (Math.random() - 0.5) * 6,
                    -9.9
                );
                drawing.userData = { collected: false, type: 'drawing' };
                wallDrawings.push(drawing);
                scene.add(drawing);
            }
        }

        function setupControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableZoom = true;
            controls.enableRotate = true;
            controls.minDistance = 3;
            controls.maxDistance = 15;
        }

        function onKeyDown(event) {
            keys[event.code] = true;

            if (event.code === 'Space') {
                event.preventDefault();
                // Flap wings for boost
                velocity.y += 0.5;
                score.tricks++;
                updateUI();
            }

            if (event.code === 'KeyE') {
                // Spin trick
                rotation.z += Math.PI / 4;
                score.tricks++;
                updateUI();
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function updateFlightPhysics(deltaTime) {
            const acceleration = 0.01;

            // Forward/backward
            if (keys.KeyW || keys.ArrowUp) {
                speed += acceleration;
            }
            if (keys.KeyS || keys.ArrowDown) {
                speed -= acceleration * 0.5;
            }

            // Steering (left/right)
            if (keys.KeyA || keys.ArrowLeft) {
                rotation.y += 0.02;
            }
            if (keys.KeyD || keys.ArrowRight) {
                rotation.z += 0.01; // Slight roll
            }

            speed = Math.max(0, Math.min(speed, 0.3)); // Clamp speed

            // Apply physics
            velocity.x = Math.sin(rotation.y) * speed;
            velocity.z = Math.cos(rotation.y) * speed;
            velocity.y -= 0.005; // Gravity

            // Add wind
            velocity.x += windDirection.x * 0.01;
            velocity.y += windDirection.y * 0.01;
            velocity.z += windDirection.z * 0.01;

            // Update position
            plane.position.x += velocity.x;
            plane.position.y += velocity.y;
            plane.position.z += velocity.z;

            // Update rotation
            plane.rotation.x = rotation.x;
            plane.rotation.y = rotation.y;
            plane.rotation.z = rotation.z;

            // Room boundaries (bounce off walls)
            if (plane.position.x > 9 || plane.position.x < -9) {
                velocity.x *= -0.8;
                plane.position.x = Math.max(-9, Math.min(9, plane.position.x));
            }
            if (plane.position.y > 4.5 || plane.position.y < 0.5) {
                velocity.y *= -0.6;
                plane.position.y = Math.max(0.5, Math.min(4.5, plane.position.y));
            }
            if (plane.position.z > 9 || plane.position.z < -9) {
                velocity.z *= -0.8;
                plane.position.z = Math.max(-9, Math.min(9, plane.position.z));
            }

            // Check collisions
            checkCollisions();
        }

        function checkCollisions() {
            // Check collectible collisions
            collectibles.forEach((item, index) => {
                if (!item.userData.collected) {
                    const distance = plane.position.distanceTo(item.position);
                    if (distance < 2.0) { // Larger collision radius for huge world
                        item.userData.collected = true;
                        item.visible = false;

                        // Update score based on item type
                        switch(item.userData.type) {
                            case 'star': score.stars++; break;
                            case 'flower': score.flowers++; break;
                            case 'coin': score.coins++; break;
                            case 'carrot': score.carrots++; break;
                        }

                        updateUI();

                        // Check for zone completion
                        const zoneData = zones[currentZone];
                        if (score.stars >= zoneData.stars) {
                            // Zone completed! Could add zone transition here
                            showZoneCelebration();
                        }
                    }
                }
            });
        }

        function updateUI() {
            document.getElementById('stars-count').textContent = score.stars;
            document.getElementById('drawings-found').textContent = score.drawings;
            document.getElementById('tricks-done').textContent = score.tricks;
            document.getElementById('flight-time').textContent = Math.floor(flightTime);
        }

        function showCelebration() {
            const celebration = document.getElementById('celebration-message');
            celebration.style.display = 'block';
            setTimeout(() => {
                celebration.style.display = 'none';
            }, 3000);
        }

        function resetPlane() {
            plane.position.set(0, 2, 0);
            velocity = { x: 0, y: 0, z: 0 };
            rotation = { x: 0, y: 0, z: 0 };
            speed = 0;

            // Reset stars
            stars.forEach(star => {
                star.visible = true;
                star.userData.collected = false;
            });

            // Reset drawings
            wallDrawings.forEach(drawing => {
                drawing.scale.setScalar(1);
                drawing.userData.collected = false;
            });

            score = { stars: 0, drawings: 0, tricks: 0 };
            flightTime = 0;
            updateUI();
        }

        function toggleAutoPilot() {
            autoPilot = !autoPilot;
            if (autoPilot) {
                // Simple auto-pilot: fly in circles collecting items
                setInterval(() => {
                    if (autoPilot) {
                        rotation.y += 0.02;
                        speed = 0.1;
                    }
                }, 50);
            }
        }

        function addWind() {
            windDirection = {
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.05,
                z: (Math.random() - 0.5) * 0.1
            };
            setTimeout(() => {
                windDirection = { x: 0, y: 0, z: 0 };
            }, 5000);
        }

        function changeTheme() {
            const colors = [
                0xe8f4f8, // Light blue
                0xf5f6fa, // Light gray
                0xffecd2, // Peach
                0xe1f5fe, // Light cyan
                0xf3e5f5  // Light purple
            ];
            const newColor = colors[Math.floor(Math.random() * colors.length)];
            scene.background = new THREE.Color(newColor);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createZoneCollectibles() {
            // Clear existing collectibles
            collectibles = [];
            stars.forEach(star => scene.remove(star));
            flowers.forEach(flower => scene.remove(flower));
            coins.forEach(coin => scene.remove(coin));
            carrots.forEach(carrot => scene.remove(carrot));

            stars = [];
            flowers = [];
            coins = [];
            carrots = [];

            // Create zone-specific collectibles
            const collectibleCount = zones[currentZone].stars;
            for (let i = 0; i < collectibleCount; i++) {
                createCollectibleItem(currentZone, i);
            }
        }

        function createCollectibleItem(zoneType, index) {
            let geometry, material, mesh, type;

            switch(zoneType) {
                case 'night':
                    geometry = new THREE.OctahedronGeometry(0.5, 0);
                    material = new THREE.MeshLambertMaterial({ color: 0xffd700, emissive: 0x444400 });
                    type = 'star';
                    break;
                case 'meadow':
                    geometry = new THREE.ConeGeometry(0.3, 1, 6);
                    material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                    type = 'flower';
                    break;
                case 'city':
                    geometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
                    material = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                    type = 'coin';
                    break;
                case 'farmland':
                    geometry = new THREE.CylinderGeometry(0.1, 0.2, 0.8, 6);
                    material = new THREE.MeshLambertMaterial({ color: 0xff6b35 });
                    type = 'carrot';
                    break;
            }

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                (Math.random() - 0.5) * worldSize * 0.8,
                Math.random() * 20 + 5,
                (Math.random() - 0.5) * worldSize * 0.8
            );
            mesh.userData = { collected: false, type: type, index: index };
            collectibles.push(mesh);

            // Add to appropriate array
            switch(type) {
                case 'star': stars.push(mesh); break;
                case 'flower': flowers.push(mesh); break;
                case 'coin': coins.push(mesh); break;
                case 'carrot': carrots.push(mesh); break;
            }

            scene.add(mesh);
        }

        function updateCamera() {
            if (!autoPilot && plane) {
                // Smooth 3rd person camera follow
                const idealOffset = new THREE.Vector3(
                    cameraOffset.x,
                    cameraOffset.y,
                    cameraOffset.z
                );

                // Rotate offset based on plane direction
                idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), plane.rotation.y);

                const idealPosition = new THREE.Vector3().copy(plane.position).add(idealOffset);

                // Smooth camera movement
                camera.position.lerp(idealPosition, 0.05);

                // Look at plane with slight offset
                cameraTarget.copy(plane.position);
                cameraTarget.y += 1;
                camera.lookAt(cameraTarget);
            }
        }

        function updateFlightPhysics(deltaTime) {
            const acceleration = 0.02; // Higher acceleration for huge world

            // Forward/backward
            if (keys.KeyW || keys.ArrowUp) {
                speed += acceleration;
            }
            if (keys.KeyS || keys.ArrowDown) {
                speed -= acceleration * 0.5;
            }

            // Steering (left/right)
            if (keys.KeyA || keys.ArrowLeft) {
                rotation.y += 0.03; // More responsive steering
            }
            if (keys.KeyD || keys.ArrowRight) {
                rotation.y -= 0.03;
                rotation.z = -0.1; // Slight bank
            } else if (!keys.KeyA && !keys.ArrowLeft) {
                rotation.z *= 0.95; // Level out
            }

            speed = Math.max(0, Math.min(speed * 0.99, 2.0)); // Higher max speed, momentum

            // Apply physics
            velocity.x = Math.sin(rotation.y) * speed;
            velocity.z = Math.cos(rotation.y) * speed;
            velocity.y -= 0.01; // Gravity

            // Add wind
            velocity.x += windDirection.x;
            velocity.y += windDirection.y;
            velocity.z += windDirection.z;

            // Update position (no boundaries in huge world)
            plane.position.x += velocity.x;
            plane.position.y += velocity.y;
            plane.position.z += velocity.z;

            // Update rotation
            plane.rotation.x = rotation.x * 0.1; // Slight pitch from speed
            plane.rotation.y = rotation.y;
            plane.rotation.z = rotation.z;

            // Ground collision (don't fall through)
            if (plane.position.y < 2) {
                plane.position.y = 2;
                velocity.y = Math.max(0, velocity.y);
                if (speed > 0.1) velocity.y = speed * 0.2; // Bounce effect
            }

            // World wrap-around (seamless huge world)
            const halfSize = worldSize / 2;
            if (plane.position.x > halfSize) plane.position.x = -halfSize;
            if (plane.position.x < -halfSize) plane.position.x = halfSize;
            if (plane.position.z > halfSize) plane.position.z = -halfSize;
            if (plane.position.z < -halfSize) plane.position.z = halfSize;

            // Check collisions
            checkCollisions();
        }

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            flightTime += deltaTime;

            updateFlightPhysics(deltaTime);
            updateCamera();

            // Animate collectibles
            collectibles.forEach((item, index) => {
                if (!item.userData.collected) {
                    item.rotation.y += 0.02;
                    if (item.userData.type === 'star') {
                        item.position.y += Math.sin(currentTime * 0.002 + item.position.x * 0.01) * 0.005;
                    } else if (item.userData.type === 'flower') {
                        item.rotation.x += 0.01;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // Initialize canvas size properly
        setTimeout(() => {
            const canvas = document.getElementById('simulator-canvas');
            const rect = canvas.getBoundingClientRect();
            renderer.setSize(rect.width, rect.height);
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
        }, 100);
    </script>
</body>
</html>
